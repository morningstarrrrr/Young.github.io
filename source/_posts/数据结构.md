---
title: 数据结构
date: 2021-08-04 17:54:42
tags: 数据结构
categories: 学习
cover: https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/DataStructure.png
description: 青岛大学-王卓《数据结构与算法基础》学习记录
---

<center>数据结构</center>

---

## <center>绪论</center>

### 🎈数据结构的研究内容

**计算机解决问题的步骤：**

* 将问题抽象为<font color="red">数学模型</font>
* 设计算法
* 编程、调试、运行



**早期，计算机应用于数值计算：**

* 分析问题，找出对象以及对象之间的关系
* 建立数学方程
* 求解



**随着计算机应用领域的扩展，越来越多被用于非数值计算：**

* 线性表
* 树
* 图

以上都是“非数值计算”的程序设计问题



> 综上所述，数据结构是一门研究<font color="red">非数值计算的</font>程序设计中计算机的<font color="red">操作对象</font>以及他们之间的<font color="red">关系</font>和<font color="red">操作</font>的学科。

### 🎈基本概念和术语

#### 数据、数据元素、数据项和数据对象

1. 数据(Data)：是描述客观事物的符号，是计算机中可以操作的对象，是能被输入计算机且能被计算机处理的各种符号的集合。

   包括：

* 数值型数据：整数、实数等
* 非数值型数据：文字、图像、图形、声音等

2. 数据元素(Data element)：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，也称为元素、记录、结点或顶点。
3. 数据项：构成数据元素的不可分割的最小单位

> <font color="red">以上三者之间的关系：</font>数据>数据元素>数据项

4. 数据对象(Data Object)：性质相同的数据元素的结合，是数据的一个子集。

   数据元素和数据对象与数据的关系的区别：

* 数据元素是集合的个体
* 数据对象是集合的子集

#### 数据结构

* 数据元素互相之间的关系称为<font color="red">结构</font>

* 是指相互之间存在一种或多种特定关系的数据元素集合

* <font color="red">包含以下三方面内容：</font>

  1. 数据元素之间的逻辑关系，也称为<font color="red">逻辑结构</font>
  2. 数据元素及其关系在计算机内存中的表示（又称为映像）称为数据的<font color="red">物理结构</font>或数据的<font color="red">存储结构</font>
  3. 数据的<font color="red">运算和实现，</font>即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现

* 数据结构的两个层次：

  1. <font color="red">逻辑结构：</font>是指数据对象中数据元素之间的互相关系

     **逻辑结构的种类：**

     划分方法一：

     1. <font color="red">线性结构：</font>有且仅有一个开始和终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。（线性表、栈、队列、字符串、数组、广义表）
     2. <font color="red">非线性结构：</font>一个结点可能有多个直接前驱和直接后继。（树形结构、图形结构）

     划分方法二：

     1. <font color="red">集合结构：</font>其中的数据元素只有<font color="red">只属于一个集合</font>的关系
     2. <font color="red">线性结构：</font>数据元素存在<font color="red">一对一</font>的线性关系
     3. <font color="red">树形结构：</font>数据元素存在<font color="red">一对多</font>的线性关系
     4. <font color="red">图状/网状结构：</font>数据元素存在<font color="red">多对多</font>的线性关系

  2. <font color="red">物理结构（存储结构）：</font>是指数据的逻辑结构在计算机中的存储形式

     **存储结构的种类：**

     ​	<font color="red">四种基本的存储结构：</font>

     ​	1.<font color="red">顺序存储结构：</font>用一组连续的存储单元一次存储数据元素，数据元素之间的逻辑关系用存储位置表示

     ​	2.<font color="red">链式存储结构：</font>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示

     ​	3.<font color="red">索引存储结构：</font>在存储结点信息的同时，还建立附加的索引表（其中的每一项称为索引项）

     ​	4.<font color="red">散列存储结构：</font>根据结点的关键字直接计算出该结点的存储地址

     **逻辑结构和存储结构之间的关系：**

     * 存储结构是逻辑关系的映像与元素本身的映像
     * 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
     * 两者综合起来建立了数据元素之间的结构关系


#### 数据类型

数据类型(Data Type):是指一组性质相同的<font color="red">值的集合</font>及定义在此集合上的<font color="red">一组操作</font>的总称

> 数据类型 = 值的集合 + 值集合上的一组操作

**在C语言中，按照取值的不同，可以分为两类：**

* 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等
* 结构类型：有若干个类型集合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的

#### 抽象数据类型

{% label 抽象是指抽取出事物具有的普遍性的本质。 red %}

通过对已有的数据类型进行抽象得到。

抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。

* 由用户定义，从问题中抽象出<font color="red">数据模型</font>（逻辑结构）。
* 还包括定义在数据模型上的一组<font color="red">抽象运算</font>（相关操作）。

**抽象数据类型的形式定义：**

抽象数据类型可以用（D，S，P）<font color="red">三元组</font>表示。

其中：D是数据对象；

​			S是D上的关系集；

​			P是对D的基本操作集。

**抽象数据类型的定义格式如下：**

```c++
ADT 抽象数据类型名
{
	数据对象：<数据对象的定义>		//其中，数据对象和数据关系用伪代码描述
	数据关系：<数据关系的定义>		//基本操作的定义格式为：
	基本操作：<基本操作的定义>		// 基本操作名（参数表）
}ADT 抽象数据类型名			   // 初始条件：<初始条件描述>
    							// 操作结果：<操作结果描述>                     
```

------

**基本操作**定义格式说明：

参数表：赋值参数 只为操作提供输入值

​				引用参数 以&打头，除可提供输入值外，还将返回操作结果

初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。

操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果。

```
ADT 抽象数据类型名{
Data
	数据对象的定义
	数据元素之间逻辑关系的定义
Operation
	操作1
		初始条件
		操作结果描述
	操作2
		...
	操作n
		...
		
}ADT 抽象数据类型名
```



## <center>算法</center>

**数据额结构和算法的关系是相互依赖不可分割的。**

### 🎈算法定义

算法是解决特定问题**求解方法和步骤**的描述，在计算机中表现为<font color="red">指令</font>的有限<font color="red">序列</font>，并且每条指令表示一个或多个操作。

**算法的描述：**

* 自然语言：中文、英语
* 流程图
* 伪代码
* 程序代码

**算法与程序：**

**算法**是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法

**程序**是用某种程序设计语言对算法的具体实现

> 程序 = 数据结构 + 算法

### 🎈算法的特性

#### 输入输出

* 算法具有零个或多个输入
* 算法至少有一个或多个输出

#### 有穷性

算法在执行有穷步之后结束，并且每一个步骤在有穷的时间内完成。

#### 确定性

算法的每一步骤都具有确定的含义，不会出现二义性，任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。

#### 可行性

算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。

### 🎈算法设计的要求

#### 正确性

算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

可以分为四个层次：

1. 算法程序<font color="red">不含语法错误</font>
2. 算法程序对于<font color="red">几组输入数据</font>能够产生满足要求的输出结果。
3. 算法程序对于<font color="red">精心选择的、典型、苛刻且带有刁难性的</font>几组输入数据能够得出满足要求的结果。
4. 算法程序对于<font color="red">一切合法的输入数据</font>都有满足要求的输出结果。

一般情况下，把<font color="red">第三层</font>作为衡量一个算法是否合格的标准。同时，一个好的算法还要容易理解。

#### 可读性

算法设计的另一目的是为了便于阅读、理解和交流。隐晦难读的算法易于隐藏较多错误难以调试

#### 健壮性

* 当<font color="red">输入非法数据</font>时，算法也能恰当做出反应和处理，而不是产生异常或莫名奇妙的结果。
* 处理出错的方法，不应该是中断程序的执行，而应返回一个表示错误或错误属性的值，以便在更高的抽象层次上进行处理。

#### 时间效率高和存储量低

设计算法应该尽量满足时间效率高和存储量低的需求。

### 🎈算法效率的度量方法

**算法效率从以下两个方面来考虑：**

<font color="red">1.时间效率： </font>指的是算法所耗费的时间

<font color="red">2.空间效率：</font>指的是算法执行过程中所耗费的存储空间

**时间效率和空间效率有时候是矛盾的**

#### 事后统计方法

将算法实现，测试其时间和空间开销。缺陷：编写程序耗费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣。

#### 事前分析估算方法

**<font color="red">算法运行时间指算法中每条语句的频度之和（假设每条语句时间为单位时间）</font>**

在计算机程序编制前，依据统计方法对算法进行估算。

程序在计算机上运行时所消耗的时间取决于下列因素：

1. 算法采用的策略、方法
2. 编译产生的代码质量
3. 问题的输入规模
4. 机器指令执行的速度

> 抛开软件和硬件的因素，一个程序的运行时间，依赖于**算法的好坏和问题的输入规模**。问题输入规模是指输入量的多少。

**在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。**

### 🎈函数的渐近增长

> 定义：给定两个函数f（n）和g（n），如果存在一个整数N，是的对于所有n>N，f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快于g（n）。

结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。

### 🎈算法时间复杂度

#### 算法时间复杂度定义

> 在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间量度，记作 T(n)=O(f(n)) 。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作<font color="red">**渐进时间复杂度**</font>，简称为时间复杂度。一般情况下，不必计算所有操作的 执行次数，而只考虑算法中**基本操作**执行的次数，它是问题规模n的某个函数，用T（n）表示。

这样用大写 O() 来体现算法时间复杂度的记法，称之为大O记法。

一般情况下，随着n的增大，T（n）增长最慢的算法为最优算法。

**分析算法时间复杂度的基本方法：**

1. 找出<font color="red">语句频度最大</font>的那条语句作为<font color="red">基本语句</font>
2. 计算<font color="red">基本语句</font>的频度得到问题规模n的某个函数f（n）
3. 取其数量级用符号“O”表示

#### 推导大O阶方法

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数
4. 得到的结果就是大O阶

#### 常数阶

如果一个算法，无论n为多少，上面的两端代码执行的次数是不变的。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O（1）的时间复杂度，又叫常数阶。

{% label 即执行次数恒定，不会随着n的变大而发生变化 red %}

#### 线性阶

要确定某个算法的阶次，我们常常要确定某个特定语句或者某个语句集运行的次数。因此，我们要**分析算法的复杂度，关键就是要分析循环结构的运行情况**。

下面这段代码，它的循环的时间复杂度为O（n），因为循环体中的代码需要执行n次。

```c++
int i;
for(i = 0; i < n; i++)
{
	/* 时间复杂度为O（1）的程序步骤序列 */
}
```

#### 对数阶

```c++
int count = 1;
while(count < n)
{
	count = count * 2;
	/* 时间复杂度为O（1）的程序步骤序列 */
}
```

有多少个2相乘后大于n，就会退出循环。由 2<sup>x</sup>=n 得到 x=log<sub>2</sub>n 。所以这个循环的时间复杂度为 O(log<sub>n</sub>) 。

#### 平方阶

```c++
int i,j;
for (i = 0; i < n; i++)
{
	for (j = 0; j < n; J++)
	{
		/* 时间复杂度为O（1）的程序步骤序列 */
	}
}
```

它的内循环的时间复杂度为O（n），而它的外循环是对于内部时间复杂度为O（n）的语句，再循环n次。所以它的时间复杂度为O（n<sup>2</sup>）。

如果外循环的循环次数改成了m，那么时间复杂度就变为O（m*n）。

总结得出，<font color="red">循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</font>。

对于下面这个循环嵌套：

```c++
int i,j;
for(i = 0; i < n; i++)
{
	for (j = i; j < n; j++) /* 注意int j = i 而不是0 */
	{
		/* 时间复杂度为O（1）的程序步骤序列 */
	}
}
```

当i=0时，内循环执行了n次，当i=1时，内循环执行了n-1次，……当i=n-1时，执行了1次。所以总执行次数为：

<center>n+(n-1)+(n-2)+···+1=n(n+1)/2+n/2</center>

用推导大O阶的方法，得出这段代码的时间复杂度为O（n<sup>2</sup>）。



#### 算法的加法法则和乘法法则

* 加法法则

  T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O( max ( f(n) , g(n) ) )

* 乘法法则

  T(n) = T1(n) * T2(n) = O(f(n)) + O(g(n)) = O( f(n) * g(n) )

#### 🎈常用的时间复杂度

|            执行次数函数            |           阶           |     非正式术语      |
| :--------------------------------: | :--------------------: | :-----------------: |
|                 12                 |         O（1）         |       常数阶        |
|                2n+3                |         O（n）         |       线性阶        |
|        3n<sup>2</sup>+2n+1         |   O（n<sup>2</sup>）   |       平方阶        |
|        5log<sub>2</sub>n+20        | O（log<sub>2</sub>n）  |       对数阶        |
|      2n+3nlog<sub>2</sub>n+19      | O（nlog<sub>2</sub>n） | nlog<sub>2</sub>n阶 |
| 6n<sup>3</sup>+2n<sup>2</sup>+3n+4 |   O（n<sup>3</sup>）   |       立方阶        |
|           2<sup>n</sup>            |   O（2<sup>n</sup>）   |       指数阶        |

常用的时间复杂度所耗费的时间从小到大依次是：

> O（1）<O（log<sub>2</sub>n）< O（n）<O（nlog<sub>2</sub>n）<O（n<sup>2</sup>）<O（n<sup>3</sup>）<O（2<sup>n</sup>）<O（n！）<O（n<sup>n</sup>）

### 🎈最坏情况与平均情况

* **最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。**
* 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。（一般通过运行一定数量的实验数据后估算出来的）

### 🎈算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作： S(n) = O(f(n)) ，其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数。

**算法要占据的空间：**

* 算法本身要占据的空间，输入/输出，指令，常数，变量等
* 算法要使用<font color="red">辅助空间</font>

------

## <center>🍟线性表</center>

### 🎵线性表的定义和特点

**线性表(Linear List):**

* 由n个数据元素（结点）组成的<font color="red">有限序列</font>
* 其中数据元素的个数n定义为表的长度
* 当n=0时称为空表
* 数据元素ai只是一个抽象的符号，其具体含义在不同的情况下可以不同

<font color="red">同一线性表中的元素必定具有相同特征，数据元素间的关系是线性关系</font>

#### **线性表的逻辑特征**

1. 非空的线性表有且只有一个开始结点，它没有直接前驱，而且仅有一个直接后继
2. 有且只有一个终端结点，它没有直接后继，而仅有一个直接前驱
3. 其余的内部结点有且只有一个直接前驱和一个直接后继

<font color="red">线性表是一种典型的线性结构</font>

**总结：**

* 线性表中的数据元素的类型可以为**简单类型**，也可以为**复杂类型**
* 许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序
* 从具体应用中抽象处共性的**逻辑结构和基本操作**（抽象数据类型），然后实现其**存储结构和基本操作**



#### **顺序表的类型定义**

* 抽象数据类型线性表的定义如下：

```c++
ADT List{
	数据对象：D = {ai|ai∈Elemset,(i=1,2,...,n,n>=0)}
	数据关系：R = {<ai-1,ai>|ai-1,ai∈D,(i=2,3,...n)}    //这里的ai中的i都是下标
	基本操作：
	InitList(&L);
	ListInsert(&L,i,e);
	DestroyList(&L);
	ListDelete(&L,i,&e);
	......等等
}ADT List
```



### 🎵基本操作

* InitList(&L)   (Initiallization List)

  * 操作结果：构造一个空的线性表L

* DestroyList(&L)

  * 初始条件：线性表L已经存在

  * 操作结果：销毁线性表L

* ClearList(&L)

  * 初始条件：线性表L已经存在

  * 操作结果：将线性表L重置为空表

* ListEmpty(L);

  * 初始条件：线性表L已经存在

  * 操作结果：若线性表L为空表，则返回TRUE；否则返回FALSE

* ListLength(L

  * 初始条件：线性表L已经存在

  * 操作结果：返回线性表L中的数据元素的个数

* GetElem(L,i,&e)

  * 初始条件：线性表L已经存在，1 <= i <= ListLength(L)
  * 操作结果：用e返回线性表L中第i个数据元素的值

* LocateElem(L,e,compare())

  * 初始条件：线性表L已经存在，compare()是数据元素判定函数
  * 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0

* PriorElem(L,cur_e,&pre_e)

  * 初始条件：线性表L已经存在
  * 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义

* NextElem(L,cur_e,&next_e)

  * 初始条件：线性表L已经存在
  * 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无意义

* ListInsert(&L,i,e)

  * 初始条件：线性表L已经存在， 1 <= i<= ListLength(L) + 1
  * 操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加1

* ListDelete(&L,i,&e)

  * 初始条件：线性表L已经存在， 1 <= i<= ListLength(L) 
  * 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一

* ListTraverse(&L,visited())

  * 初始条件：线性表L已经存在
  * 操作结果：依次对线性表中每个元素调用visited()



**以上的运算都是逻辑结构上定义的运算，只有在确定了存储结构之后才考虑具体的实现细节。**





### 🎵线性表的顺序存储表示

顺序表的顺序表示又称为<font color="red">顺序存储结构</font>或<font color="red">顺序映像</font>

#### <font color="red">**顺序存储定义**</font>

把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的顺序结构

* 依次存储，地址连续——中间<font color="red">没有空出存储单元</font>

* 线性表顺序存储结构<font color="red">占用一片连续的存储空间。</font>知道某个元素的存储位置就可以计算其他元素的存储位置



#### **顺序表中元素存储位置的计算**

* 假设线性表中每个匀速需要占K个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：<font color="red">LOC(a~i+1~) = LOC(a~i~) + K</font>

* 所有数据元素的存储位置均可由第一个数据元素的存储位置得到：<font color="red">LOC(a~i~) = LOC(a~1~) + (i-1) * K </font>。其中<font color="red">LOC(a~1~) </font>称为<font color="red">基地址</font>。



#### **顺序表的特点**

<font color="red">以物理位置相邻表示逻辑关系。任意元素均可随机存取</font>（优点）

顺序表与数组特点相同：地址连续、依次存放、随机存取、类型相同即<font color="red">用一维数组表示顺序表</font>

但线性表长度可变（删除），数组长度不可动态定义

一维数组定义方式：``类型说明符 数组名[常量表达式]``

说明：常量表达式中可以包含常量和符号常量，不能包含变量。即C语言中不允许对数组的大小作动态定义。<font color="red">即需要重新用一个变量表示线性表的长度，且在程序开头就定义一个常量作为线性表可能达到的最大长度</font>。



#### **定义顺序表类型**

```
#define MAXSIZE 100
typedef struct{
	ElemType *elem;
	int length;
}SqList;  //定义数据表类型

SqList L; //定义变量L
```



### **🎵顺序表基本操作的实现**

#### 操作算法中用到的预定义常量和类型

```c++
//函数结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
//Status 是函数类型
typedef int Status;
```

#### 线性表L的初始化

```c++
Status InitList_Sq(SqList &L){
	L.elem = new ElemType[MAXSIZE];
	if(!L.elem)exit(OVERFLOW);
	L.length=0;
	return OK;
}
```

#### 销毁线性表

```c++
void DestoryList(SqList &L){
	if(L.elem) delete L.elem;
}
```

#### 清空线性表

```c++
void ClearList(SqList &L){
	L.length = 0;
}
```

#### 求线性表长度

```c++
int GetLength(SqList L){
	return(L.length);
}
```

#### 判断线性表L是否为空

```c++
int IsEmpty(SqList L){
	if(L.length == 0) return 1;
	else return 0;
}
```

#### 顺序表取值

```c++
int GetElem(SqList L,int i,ElemType &e){
	if(i<1||i>L.length) return ERROR;  //判断i的值是否合理
	e = L.elem[i-1];
	return OK;
}
```

#### 顺序表的查找

```c++
int LocateElem(SqList L,ElemType e){     //查找值为e的元素，返回其序号
	for(i=0;i<L.length;i++){
		if(L.elem[i] == e) return i+1;
	}
	return 0;
}
```

**顺序表的查找算法分析**

平均算法长度ASL(Average Search Length):为确定记录在表中的位置，需要与给定值进行比较的关键字的个数期望值叫做查找算法的平均查找长度。

* 用第i个记录被查找的概率乘以找到第i个记录需要比较的次数相加

(1/n)*[(n+1)(n) / 2]

顺序表查找的时间复杂度为O（n）



#### 顺序表的删除

```c++
Status ListDelete_Sq(SqList &L,int i){
	if((i<1)||(i>L.length)) return ERROR;
	for(j=i;j<=L.length;j++){
		L.elem[j-1]=L.elem[j];
	}
	L.length--;
	return OK;
}
```

#### **顺序表的删除算法分析**

(1/n)*[(n-1)n / 2]

顺序表删除的时间复杂度O（n）



### 🎵线性表的链式存储表示

* 用一组<font color="red">物理位置任意的存储单元</font>来存放线性表的数据元素
* 这组存储单元既可以是<font color="red">连续</font>的，也可以是<font color="red">不连续</font>的，甚至是零散分布在内存中的任意位置上的
* 链表中元素的<font color="red">逻辑次序和物理次序不一定相同</font>



#### **与链式存储有关的术语**

1. <font color="red">结点：</font>数据元素的存储映像。由数据域和指针域两部分组成
2. <font color="red">链表：</font>n个结点由<font color="red">指针链</font>组成一个链表
3. <font color="red">单链表、双链表、循环链表：</font>
   * 结点只有一个指针域的链表，称为单链表或线性链表
   * 结点有两个指针域的链表，称为双链表
   * 首尾相接的链表称为循环链表
4. <font color="red">头指针、头结点、首元结点</font>



#### <font color="red">**讨论**</font>

**如何表示空表？**

* 无头结点时，<font color="red">头指针为空</font>表示空表
* 有头结点时，<font color="red">当头结点的指针域为空时</font>表示空表

**在链表中设置<font color="red">头结点</font>有什么好处？**

* 便于<font color="red">首元结点</font>的处理
* 便于<font color="red">空表与非空表</font>的统一处理

**头结点的<font color="red">数据域</font>中装的是什么？**

头结点的<font color="red">数据域</font>可以为空，也可以存放线性<font color="red">表长度</font>等附加信息，但此结点不能计入链表长度



#### <font color="red">链表（链式存储结构）的特点</font>

1. 结点在存储器中的位置是任意的，即在逻辑上相邻的元素在物理上不一定相邻
2. 访问时只能通过头指针访问链表，并通过每个结点的指针域依次向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等

这种数据元素的存储方法称为<font color="red">顺序存取法</font>



#### 单链表的定义和表示

单链表是<font color="red">由表头</font>唯一确定，因此单链表可以用<font color="red">头指针</font>的名字来命名，若头指针名是L，则把链表称为<font color="red">表L</font>。

**单链表的存储结构：**

```c++
typedef struct Lnode{
	ElemType data;
	struct Lnode *next;
}Lnode,*LinkList;
```

虽然LinkList X 和 Lnode *X 都能表示新建一个指针，但一般用<font color="red">LinkList L 创建链表</font>，用<font color="red">Lnode *p 来创建指向结点的指针</font>。



### 🎵单链表基本操作的实现

#### 单链表的初始化

```c++
Status InitList_L(LinkList &L){
	L = new LNode;   //从内存中申请一个存放LNode类型的空间，L指向它
	L->next = NULL;
	return OK;
}
```

#### 判断链表是否为空

```c++
int ListEmpty(LinkList L){	//若表为空，返回1；不为空，返回0
	if(L->next)
		return 0;	//非空
	else
		return 1;
}
```

#### 单链表的销毁

从头指针开始，依次释放所有结点

用一个指针p来同样指向头指针L所指的结点，然后L往后移一位，p负责删除L上一个指向的结点并重新指向L当前所指的结点，这样重复直到所有结点都被释放。

```c++
Status DestoryList_L(LinkList &L){
	LNode *P;
	while(L){
		p = L;
		L = L->next;
		delete p;
	}
    return OK;
}
```

#### 清空单链表

链表仍存在，但链表中没有元素，只有头指针和头结点

```c++
Status ClearList(LinkList &L){
	Lnode *p, *q;
	p = L->next;	//p指向首元结点
	while(p){
		q = p->next;
		delete p;
        p = q;
	}
	L->next = NULL;	//头结点的指针域指向空
    return OK;
}
```

#### 求单链表表长

* 头结点不计入

```c++
int ListLength_L(LinkList L){
	Lnode *p;
	int i = 0;
	p = L->next;
	while(p){
		i++;
		p = p->next;
	}
	return i;
}
```

#### 单链表取值

```c++
Status GetElem_L(LinkList L;int i;ElemType &e){
	Lnode *p;p = L;int j = 0;	//初始化
	while(p && j<i){
		p = p->next;
		j++;
	}
	if(!p || j>i) return ERROR;	//这里j>i是指i为0或者负数的情况 !p有两种情况
	e = p->data;				//1.链表为空  2.i的值大于链表长度p指向空了		
	return OK;
}
```

#### 单链表的按值查找

返回指针（地址）

```c++
Lnode *LocateElem_L(LinkList L,ElemType e){
	Lnode *p;p = L->next;
	while(p && p->data != e){
		p = p->next;
	}
	return p;
}
```

返回<font color="red">位置序号</font>

```c++
int LocateElem_L(LinkList L,Elemtype e){
	Lnode *p;p = L;int j = 0;
	while(p && p->data != e){
		p = p->next;
		j++;
	}
	if(p) return j;
    else return 0;
}
```

#### 单链表的插入

```c++
Status ListInsert_L(LinkList &L,ElemType e,int i){
	Lnode *p;p = L;int j = 0;
	while(p && j<i){
		p = p->next;
		j++;
	}
	if(!p || j>i) return ERROR;
	
	s = new Lnode;s->data = e;	//这里一定要用new一块内存空间 如果只Lnode一个结点
	s->next = p->next;			//只是一个函数中的临时变量
	p->next = s;
	
	return OK;
}
```

单链表的删除

```c++
Status ListDelete_L(LinkList &L,int i,ElemType &e){
	Lnode *p;p = L;int j = 0;Lnode *q;
	while(p && j<i-1){
		p = p->next;
		j++;
	}
	if(!p || j>i-1) return ERROR;
	
	q = p->next;
	e = p->next->data;
	p->next = p->next->next;
	delete q;
	return OK;
}
```



#### 单链表的查找、插入、删除算法时间效率分析

1. 查找：线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为<font color="red">O（n）</font>
2. 插入和删除：不需要移动元素，只要修改指针，一般情况下时间复杂度为<font color="red">O（1）</font>，但是如果在不知道插入或删除的位置情况下需要查找，时间复杂度为<font color="red">O（n）</font>



#### 建立单链表

* 头插法：元素插在链表的头部(倒位序)

```c++
void CreateList_H(LinkList &L,int n){
	Lnode *p;
	L = new Lnode;
	L->next = NULL;
	
	for(i=n;i>0;i--){
		p = new Lnode;
		cin>>p->data;
		p->next = L->next;
		L->next = p;
	}
}
```

* 尾插法：元素插在链表的尾部(正位序)

```c++
void CreateList_R(LinkList &L,int n){
	Lnode *p;Lnode *r;		//需要创建一个指针来指向尾结点
    L = new Lnode;L->next = NULL;
    r = L;
	
    for(i=0;i<n;i++){
        p = new Lnode;
        cin>>p->data;
        p->next = NULL;
        r->next = p;
        r = p;
    }
}
```



### 🎵循环链表

定义：是一种头尾相接的链表（表中最后一个结点指向<font color="red">头结点</font>）

优点：可以从表中任意结点出发均可找到表中其他结点

注意：

1. 由于循环链表没有NULL指针，故涉及遍历操作时，其终止条件不再像非循环链表那样判断p或者p->next是否为空，而是<font color="red">判断它们是否等于头指针</font>

```
p != L;
p->next != NULL;
```

2. 表的操作常常是在表的首尾进行

   若用头指针表示单循环链表，寻找a~n~的时间复杂度为O（n），不方便

   所以经常用尾指针来表示单循环链表,使得寻找a~1~和a~n~的时间复杂度都为O（1）

   a~1~的存储位置：R->next->next

   a~n~的存储位置：R



**带尾指针的循环链表的合并**

```c++
LinkList Connect(LinkList Ta,LinkList Tb){
	p = Ta->next;				//存储表头结点
	Ta->next = Tb->next->next;	//Tb表头连接Ta表尾
	delete Tb->next;			//释放Tb表头结点
	Tb->next = p;				//修改指针
	return Tb;					//因为return了新的表尾  所以形参不用引用符号
}
```



### 🎵双向链表

定义：在每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中有两个方向不同的链，称为双向链表

双向链表的结构可定义如下：

```
typedef struct DuLnode{
	ElemType data;
	struct DuLnode *prior,*next;
}DuLnode,*DuLinkList;
```

#### 双向链表的插入

```c++
void ListInsert_DuL(DuLinkList &L,int i,ElemType e){
	if(!(p = GetElemP_DuL(L,i))) return ERROR;	//用p指向第i个结点
	DuLnode *s;
	s = new DuLnode;
	s->data = e;
	
	s->prior = p->prior;
	p->prior->next = s;
	s->next = p;
	p->prior = s;
	
	return OK;
}
```

#### 双向链表的删除

```c++
void ListDelete_DuL(DuLinkList &L,int i,ElemType &e){
	if(!(p = GetElemP_DuL(L,i))) return ERROR;	//寻找第i个元素的时间复杂度O(n)
	e = p->data;
	p->prior->next = p->next;	//删除元素所需要的时间复杂度为 O(1)
	p->next->prior = p->prior;
	delete p;
	return OK;
}
```

### 🎵单链表、循环链表和双向链表的时间效率比较

|                                   | 查找首元结点           | 查表表尾结点                         | 查找结点*p的前驱结点                   |
| --------------------------------- | ---------------------- | ------------------------------------ | -------------------------------------- |
| 带头结点的单链表L                 | L->next 时间复杂度O(1) | 从L->next依次向后遍历 时间复杂度O(n) | 通过p->next无法找到前驱                |
| 带头结点且仅设头指针L的循环单链表 | R->next 时间复杂度O(1) | 从L->next依次向后遍历 时间复杂度O(n) | 通过p->next可以找到前驱 时间复杂度O(n) |
| 带头结点且仅设尾指针R的循环单链表 | R->next 时间复杂度O(1) | R 时间复杂度O(1)                     | 通过p->next可以找到前驱 时间复杂度O(n) |
| 带头结点的双向循环链表            | R->next 时间复杂度O(1) | R 时间复杂度O(1)                     | p->prior 时间复杂度O(1)                |

* 带头结点的双向循环链表，本质上还是用空间换取时间效率



### 🎵线性表的应用

#### 线性表的合并

思路：依次取出Lb中的每个元素，在La中查找该元素，如果找不到，插入到La表的最后

```c++
void union(SqList &La,SqList Lb){
	La_len = ListLength(La);
	Lb_len = ListLength(Lb);
	
	for(i=1;i<=Lb_len;i++){
		GetElem(Lb,i,e);
		if(!LocateElem(La,e)) ListInsert(&La,++La_len,e);
	}
}
```

* 算法的时间复杂度为 O( ListLength(La) * ListLength(Lb) )



#### 有序表的合并

* 顺序表的实现

```c++
void MergeList_Sq(SqList La,SqList Lb,SqList &Lc){
	ElemType *pa,*pb,*pc;
	ElemType *La_last,*Lb_last;				//指针类型要和元素类型对应
	pa = La.elem;							//分别指向两个顺序表第一个元素的指针
	pb = Lb.elem;
	
	Lc.length = La.length + Lb.length;
	Lc.elem = new ElemType[Lc.length];		//为新表分配一个数组空间
	pc = Lc.elem;
	
	pa_last = La.elem + La.length - 1;		//分别指向表中的最后一个元素
	pb_last = Lb.elem + Lb.length - 1;
	
	while(pa <= pa_last && pb <= pb_last){	//两个表都非空
		if(*pa <= *pb) *pc++ = *pa++;
		else *pc++ = *pb++;
	}
	
	while(pa <= pa_last) *pc++ = *pa++;		//将剩余元素填入表c
    while(pb <= pb_last) *pc++ = *pb++;
	
}
```

算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )     比较步骤和剩余填入步骤 之和

算法的空间复杂度：O( ListLength(La) + ListLength(Lb) ) 

* 链表实现

```c++
void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc){
	Lnode *pa,*pb,*pc;
	pa = La->next;	pb = Lb->next;		//分别指向La和Lb的首元结点
	pc = Lc = La;	//用La的头结点作为Lc的头结点 pc是表Lc中指向最后一个元素的指针
	
	while(pa && pb){
		if(pa->data <= pb->data){pc->next = pa; pc = pa; pa = pa->next;}
		else(pc->next = pb; pc = pb; pb = pb->next;)
	}
	//当La和Lb有一个表填完
	pc->next = pa ? pa:pb;
	
	//释放Lb的头结点
	delete Lb;
}
```

算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )        计算的是最坏情况下的

算法的空间复杂度：O(1) 不需要额外的空间，修改La和Lb指针得到

### **🎵补充**

#### **数组定义**

数组静态分布

```c++
typedef struct{
	ElemType data[maxsize];
	int length;
}SqList;
```

数组动态分布

```c++
typedef struct{
	ElemType *data;	//数组的名字存放的是数组的首地址，所以也可以直接定义一个指针变量
	int length;		//来存放数组的首地址
}SqList;

SqList L;
L.data = (ElemType*)malloc(sizeof(ElemType)*maxsize);
```

#### **C语言动态存储分配**

对于c来说 (ElemType*)malloc(m) ，后面的括号是申请的内存空间的大小，前面的括号是强制转换类型，即将申请的空间转换成什么类型，并返回申请空间的首地址，由指针指向这个首地址。删除用free()。

<font color="red">需要加载头文件：<stdlib.h></font>(C语言)



#### **C++的动态存储分配**

``new 类型名T(初值列表)``

功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值

成功：T类型的指针，指向新分配的内存

失败：0（NULL）

```c++
int *p1 = new int;		//不赋初值
int *p1 = new int(10);	//赋初值
```

``delete 指针p``

功能：释放指针P所指向的内存。P必须是new操作的返回值。



#### **C++中的参数传递**

* 函数调用时传送给形参的实参必须与形参三个一致：类型、个数、顺序
* 参数传递有两种方式
  * 传值方式（参数为整型、实型、字符型等）
  * 传地址
    * 参数为指针变量
    * 参数为引用类型
    * 参数为数组名



#### **C++中 引用类型做参数**

```c++
void main()
{
	int i = 5;
	int &j = i;		//引用类型,j作为i的一个替代名字，会随着i的改变而改变
	i = 7;
}


void swap(float &m,float &n) //这里的m和n与主函数中的实参用的是同一块空间
{
    float temp;
    temp = n;
    n = m;
    m = temp;
}
```



#### **引用类型做形参的三种说明**

1. 传递引用给函数与传递指针的效果是一样的，<font color="red">形参变化实参也发生变化</font>。

2. 引用类型做形参，在内存中并没有产生实参的副本，它<font color="red">直接对实参操作</font>；而一般变量作参数，形参与实参就占用不同的存储单元，所以<font color="red">形参变量的值是实参变量的副本</font>。因此，当<font color="red">参数传递的数据量较大</font>时，用引用比用一般变量传递参数的时间和空间效率都好。
3. 指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。





## 栈和队列

### 栈和队列的定义和特点

* 栈和队列是两种常用的、重要的数据结构
* 栈和队列是限定插入和删除只能在表的 “端点” 进行的线性表

栈

```c++
Insert(s,n+1,x)	//插入和删除只能在表尾进行
Delete(s,n)
```

队列

```c++
Insert(q,n+1,x)	//插入在表尾进行
Delete(q,1)		//删除在表头进行
```



### 栈的定义和特点

栈(stack)是一个特殊的线性表，是限定仅在一端进行插入和删除操作的数据表

又称为<font color="red">后进先出</font>(Last In First Out)的线性表，简称<font color="red">LIFO</font>结构。



**栈的相关概念**

* 表尾（即a~n~端）称为<font color="red">栈顶</font>Top；表头（即a~1~端）称为<font color="red">栈底</font>Base

* 插入元素到栈顶（即表尾）的操作，称为<font color="red">入栈</font>		PUSH

* 从栈顶删除一个元素的操作，称为<font color="red">出栈</font>					POP

* 逻辑结构：与线性表相同，仍为一对一关系
* 存储结构：用顺序栈或链栈均可，但以顺序栈更常见
* 运算规则：只能在栈顶运算，且访问结点时依照后进先出的原则
* 实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈和链栈的不同而不同

<font color="red">与线性表的区别：</font>仅在于运算规则不同，一个随机存取，一个后进先出



### 队列的定义和特点

队列(queue)是一种<font color="red">先进先出</font>(First In First Out)的线性表。在表尾插入，在表头删除



**队列的相关概念**

* 逻辑结构：一对一
* 存储结构：顺序队或链队，以循环队列更常见
* 运算规则：只能在队首或队尾运算，且访问结点时依照先进先出原则
* 实现方式：关键是掌握入队和出队操作，且具体实现依顺序队或链队的不同而不同





### 栈的表示和实现

#### 栈的抽象数据类型的类型定义

```c++
ADT Stack{
	数据对象:
		D = {ai|ai∈ElemSet,i=1,2,3....n,n>=0}
	数据关系：
		R1 = {<ai-1,ai>|ai-1,ai∈D,i=2,3,4...n}
		约定an为栈顶，a1为栈底
	基本操作：
		初始化、进栈、出栈、取栈顶元素等
}ADT Stack
```



#### 🍨顺序栈的表示和实现

存储方式：同线性表的顺序存储结构相同，用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址端。

* 附设<font color="red">top</font>指针，指示栈顶元素在顺序栈中的位置
* 另设<font color="red">base</font>指针，指示栈底元素在顺序栈中的位置

<font color="red">但是为了方便操作，通常top指针指示真正的栈顶元素之上的下标地址</font>

* 另外，用<font color="red">stacksize</font>表示栈可用的最大容量



空栈：base == top 是栈空标志

栈满：top - base == stacksize

栈满时的处理方法：

1. 报错，返回操作系统
2. 分配更大内存空间，作为栈的存储空间，将原栈的内容移入新栈



使用数组作为顺序栈存储方式的特点：

简单、方便，但易产生溢出

* 上溢(overflow)：栈已经满，又要压入元素
* 下溢(underflow)：栈已经空，又要弹出元素



顺序栈的表示

```c++
#define MAXSIZE 100
typedef struct{
	SElemType *top;
	SElemType *base;
	int stacksize;
}SqStack;
```



##### 顺序栈的初始化

```c++
Status InitStack(SqStack &S){
	S.base = new SElemType[MAXSIZE];	//分配内存空间
	if(!S.base) exit(OVERFLOW);			//如果分配失败
	
	S.top = S.base;						//栈顶指针等于栈底指针
	S.stacksize = MAXSIZE;
	return OK;
}
```



##### 顺序栈判断栈是否为空

```c++
Status StackEmpty(SqStack s){
	if(S.top == S.base)
		return TRUE;
	else
		return FALSE;
}
```



##### 求顺序栈长度

```c++
int StackLength(SqStack S){
	return S.top-S.base;
}
```



##### 清空顺序栈

```c++
Status ClearStack(SqStack S){
	if(S.base) S.top == S.base;	//如果没有base就不用清空了；不用删除元素，令栈顶指
	return OK;					//针等于栈底指针就相当于栈为空
}
```



##### 销毁顺序栈

```c++
Status DestoryStack(SqStack &s){
	if(S.base){
		delete S.base;
		S.stacksize = 0;
		S.top = S.base = NULL;
	}
	return OK;
}
```



##### 顺序栈的入栈

```c++
Status Push(SqStack &S,SElemType e){
	if(S.top-S.base == stacksize) return ERROR;
	
	*S.top++ = e;
	return OK;
}
```



##### 顺序栈的出栈

```c++
Status Pop(SqStack &S,SElemType &e){
	if(S.top == S.base)
		return ERROR;
	e = *--S.top;
	return OK;
}
```





#### 🍨链栈的表示

* 链栈是<font color="red">运算受限</font>的单链表，只能在<font color="red">链表头部</font>进行操作

```c++
typedef struct StackNode{
	SElemType data;
	struct StackNode *next;
}StackNode,*LinkStack;
LinkStack S;
```

* 链表的头指针就是栈顶
* 不需要头结点
* 基本不存在栈满的情况
* 空栈相当于头指针指向空
* 插入和删除仅在栈顶处执行



##### 链栈的初始化

```c++
void InitStack(LinkStack &S){
	//构造一个空栈，栈顶指针置为空
	S = NULL;
	return OK;
}
```



##### 判断链栈是否为空

```c++
Status StackEmpty(LinkStack S){
	if(S == NULL) return TRUE;
	else return FALSE;
}
```



##### 链栈的入栈

```c++
Status Push(LinkStack &S,SElemType e){
	StackNode *p;
	p = new StackNode;
	p->data = e;
	p->next = S;
	S = p;
	return OK;
}
```



##### 链栈的出栈

```c++
Status Pop(LinkList &S,SElemType &e){
	if(S == NULL) return ERROR;
	e = S->data;
	
	Stacknode *p;
	p = S;
	S = S->next;
	delete p;
	return OK;
}
```



##### 取栈顶元素

```c++
SElemType GetTop(LinkStack S){
	if(S != NULL) 
	return S->data;
}
```





### 栈与递归

#### 递归的定义

* 若一个对象部分地<font color="red">包含它自己</font>，或者用它<font color="red">给自己定义</font>，则称这个对象是递归的
* 若一个过程<font color="red">直接或间接地调用自己</font>，则称这个过程是递归过程

#### 以下这三种情况常常用到递归方法

1. 递归定义的数学函数
   * 阶乘函数
   * 斐波那契数列
2. 具有递归特性的数据结构
   * 二叉树
   * 广义表
3. 可递归求解的问题
   * 迷宫问题
   * 汉诺塔问题

#### 递归问题：用分治法求解

分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解

必备的三个条件：

1. 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的的仅是处理的对象，且这些处理对象是变化有规律的
2. 可以通过上述转化而使问题简化
3. 必须有一个明确的递归出口，或称递归边界



#### 分治法求解递归问题算法的一般形式

```c++
void p(参数表){
	if(递归结束条件) 可直接求解步骤;	//基本项
	else p (较小的参数);	//归纳项
}
```



#### 函数调用过程

调用前，系统完成：

1. 将<font color="red">实参，返回地址</font>等传递给被调用函数
2. 为被调用函数的<font color="red">局部变量</font>分配存储区
3. 将控制转移到被调用函数的<font color="red">入口</font>

调用后，系统完成：

1. 保存被调用函数的计算<font color="red">结果</font>
2. 释放被调用函数的<font color="red">数据区</font>
3. 依照被调用函数保存的<font color="red">返回地址</font>将控制转移到调用函数



#### 多个函数嵌套调用

<font color="red">遵循后调用的先返回</font>



#### 递归函数调用的实现

“层次”

```
主函数		 0层
第1次调用	1层
......		
第i次调用	i层
```

“递归工作栈”	——递归程序运行期间使用的数据存储区

“工作记录”		实际参数、局部变量、返回地址



#### 递归的优缺点

优点：结构清晰，程序易读

缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。



递归——>非递归

方法1：尾递归、单向递归 ——>循环结构

方法2：自用<font color="red">栈</font>模拟系统的运行时候栈



### 队列的表示和操作的实现

#### 队列的抽象数据类型定义

```
ADT Queue{
	数据对象：D = {ai|ai∈Elemset,(i=1,2,...,n,n>=0)}
	数据关系：R = {<ai-1,ai>|ai-1,ai∈D,(i=2,3,...n)}    //这里的ai中的i都是下标
	基本操作：
		InitQueue(&Q);
		DestroyQueue(&Q);
		......
}ADT Queue
```



#### 队列的顺序表示和实现

用一维数组base[MAXQSIZE]

```c++
#define MAXQSIZE 100
typedef struct{
	QElemType *base;	//指向数组首地址
	int front;			//头指针 虽然叫做指针但不是指针变量，指的是数组中的下标
	int rear;			//尾指针
}
```



**解决假上溢的方法：**

1. 将队中元素依次向队头方向移动

   缺点：浪费时间。每移动一次，队中元素都要移动

2. 将队空间设想成一个循环的表，当rear或front等于maxsize时，若开始端空着，可以从头使用空着的空间

base[0]接在base[MAXQSIZE - 1]之后，若rear + 1 == M，则令rear = 0；

实现方法：利用<font color="red">模运算（mod,c语言中：%）</font>



**区分队空和队满**

1. 另外设置一个标志来区分队空、队满

2. 另设一个变量，记录元素个数

3. <font color="red">少用一个元素空间</font>

   用第三种方法时：

   队空：front == rear

   队满：（rear+1）% MAXQSIZE == front			//无论对front下标在哪都适用



##### 队列的初始化

```c++
Status InitQueue(SqQueue &Q){
	Q.base = new QElemType[MAXQSIZE];
	if(!Q.base) exit(OVERFLOW);
	Q.front = Q.rear = 0;
	return OK;
}
```



##### 求队列的长度

```c++
int QueueLength(SqQueue &Q){
	return((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);
}
```



##### 循环队列入队

```c++
Status EnQueue(&Q,QElemType e){
	if( (Q.rear+1) % MAXQSIZE == Q.front) return ERROR;
    Q.base[Q.rear] = e;
	Q.rear = (Q.rear + 1) % MAXQSIZE;
    return OK;
}
```



##### 循环队列出队

```c++
Status DeQueue(&Q,&QElemType e){
	if(Q.front == Q.rear) return ERROR;
	e = Q.base[Q.front];
	Q.front = (Q.front + 1) % MAXQSIZE;
	return OK;
}
```



##### 取队头元素

```c++
QElemType GetHead(Q){
	if(Q.front != Q.rear)	return Q.base[front];
}
```



#### 队列的链式表示和实现

若用户无法估计所用队列的长度，宜采用链队列

* 带头结点



##### 链队列的类型定义

```c++
#define MAXQSIZE 100
typedef struct Qnode{
	QElemType data;
	struct Qnode *next;
}Qnode,*QueuePtr;

typedef struct{
    QueuePtr front;		//头指针
    QueuePtr rear;		//尾指针
}LinkQueue;
```



##### 链队列初始化

```c++
Status InitQueue(LinkQueue &Q){
	Q.front = Q.rear = new Qnode;
	if(!Q.front) exit(OVERFLOW);
	Q.front->next = NULL;
	return OK;
}
```



##### 链队列的销毁

```c++
Status DestroyQueue(LinkQueue &Q){
	Qnode *p;
	while(Q.front){
		p = Q.front->next;
		delete Q.front;
		Q.front = p;
	}//这里Q.rear 没什么用，可以直接用它来代替p
	return OK;
}
```



##### 链队列入队

```c++
Status EnQueue(LinkQueue &Q,QElemType e){
	Qnode *p;
	p = new Qnode;
    if(!p) exit(OVERFLOW);
	p->data = e;
	p->next = NULL;
	
	Q.rear->next = p;
    Q.rear = p;
	return OK;
}
```



##### 链队列出队

```c++
Status DeQueue(LinkQueue &Q,QElemType &e){
	if(Q.front == Q.rear) return ERROR;
	Qnode *p;
	p = Q.front->next;
	e = p->data;
	Q.front->next = Q.front->next->next;
	
	if(Q.rear == p) Q.rear = Q.front;	//如果恰好删除的是尾结点，那么尾指针也指向
										// 头结点
	delete p;
	return 
}
```



##### 求链队列队头元素

```c++
Status GetHead(LinkQueue Q,QElemType &e){
	if(Q.front == Q.rear) return ERROR;
	e = Q.front->next->data;
	return OK;
}
```





## 串

### 串的定义

串（string）：零个或多个任意字符组成的有限序列

s = “a~1~a~2~···a~n~” (n>=0)

串名：s

串值：a~1~到a~n~

串长：n

空串：n=0	用∅表示

子串：串中任意个连续字符组成的子序列称为该串的子串

真子串：不包含自身的所有子串

主串：包含子串的串

字符位置：字符在序列中的序号为该字符在串中的位置

子串位置：子串中第一个字符在主串中的位置

空格串：由一个或多个空格所构成的串，与空串不同

串相等：当且仅当两个串长度相等且各个对应位置上的字符都相同，这两个串才相等

​				所有的空串都是相等的



### 串的类型定义

```
ADT String{
	数据对象：字符
	数据关系：序偶关系
	基本操作：
		1.串赋值
		2.串比较
		3.求串长
		4.串连结
		5.求子串
		6.串拷贝
		7.清空串
		8.串判空
		9.子串的位置
		10.串替换
		11.子串插入
		12.子串删除
		13.串销毁
}ADT String
```



### 串的存储结构

串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构（顺序、链式）

#### 串的顺序存储结构

```c++
#define MAXLEN 255
typedef struct{
	char ch[MAXLEN+1];	//0号位置不用
	int length;
}SString
```



#### 串的链式存储结构

与单链表类似	优点：操作方便		缺点：存储密度较低

为了克服缺点，可将多个字符放在一个结点中，称为<font color="red">块</font>

```
#define CHUNKSIZE 80
typedef struct Chunk{
	char ch[CHUNKSIZE];
	struct Chunk *next;
}Chunk;

typedef struct{
	Chunk *head,*tail;	//串的头指针和尾指针
	int curlen;			//串的当前长度
}LString;				//字符串的块链结构
```



### 串的模式匹配算法

算法目的：确定主串中所含子串（模式串）第一次出现的位置

算法应用：搜索引擎、拼写检查、语言翻译、数据压缩

算法种类：BF算法、KMP算法



#### BF算法

简单匹配算法，采用穷举法的思路

算法的思路是从S（正文串）的每一个字符开始依次与T（模式）的字符进行匹配



##### 设计思想

Index (S,T,pos)

* 将主串的第pos个字符和模式串的第一个字符比较
* 若相等，继续逐个比较后续字符
* 若不等，从主串的下一字符起，重新与模式串的第一个字符比较
* 直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的第一个子序列的第一个字符的序号，即匹配成功
* 否则，匹配失败，返回值为0



##### 算法描述

```c++
int Index_BF(SString S,SString T，int pos){	//pos是从什么位置开始寻找
	int i=pos,j=1;
	
	while(i<=S.length && j<=T.length){
		if(S.ch[i] == T.ch[j])	{++i;++j;}	//主串和子串依次匹配下一个字符
		else {j = 1; i = i - j + 2;}		//主串、子串回溯开始下一次匹配
	}
	if(j>T.length) return i-T.length;		//匹配成功返回第一个字符的下标
	else return 0;							//匹配失败
}
```



##### 算法时间复杂度

主串长度为n，子串长度为m

最好情况：O（m）

最坏情况：O [ (n-m)*m + m ]	若 m<<n，则算法复杂度为 O (m * n)



#### KMP算法

该算法较BF有较大改进，从而算法效率有了某种程度的提高



##### 算法思想

利用已经<font color="red">部分匹配</font>的结果而加快模式串的滑动速度

且主串S的指针<font color="red">i不必回溯</font>，可提速到<font color="red">O（m+n）</font>



##### next[j]数组

表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的位置

​					max	

next [j] = 	0	当j=1时

​					1	其他情况



##### 算法描述

```c++
int Index_KMP(SString S,SString T，int pos){
	int i=pos,j=1;
	
	while(i<=S.length && j<=T.length){
		if(S.ch[i] == T.ch[j])	{++i;++j;}	
		else 	j = next[j];		//i不变，j后退 （与BF算法的区别）
	}
	if(j>T.length) return i-T.length;
	else return 0;			
}
```

获得next[j]数组的函数

```c++
void get_next(SString T,int &next[]){
	i = 1;next[1] = 0;j = 0;
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j]){
			++i;++j;
			next[i] = j;  //如果i和j向后移一位后ch[i]和ch[j]相等，next[i]直接加1
		}
		else j = next[j]; //如果不相等，变成重新再找前j个字符的最长公共前缀子串，再						  //移下一位看是否相等
	}
}
```

理解：

[(7条消息) KMP算法原理描述，告诉你为什么要“j = next[j\]”_Leycaner的博客-CSDN博客_j=next[j]](https://blog.csdn.net/Leycaner/article/details/108301195)



##### next函数的改进

```c++
void get_nextval(SString T,int &nextval[]){
	i = 1;nextval[1] = 0;j = 0;
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j]){
			++i;++j;
			if(T.ch[i]!=T.ch[j]) nextval = j;
			else nextval[i] = nextval[j];
 		}
		else j = nextval[j]; 
	}
}
```



## 数组

按一定格式排列起来的具有<font color="red">相同类型</font>的数据元素的集合

**结论：**线性表是数组结构的一个特例，而数组结构又是线性表结构的扩展

**特点：**结构固定

**数组基本操作：**除了结构的初始化和销毁之外，只有取元素和修改元素值的操作



### 数组的抽象数据类型定义

<font color="red">n维数组</font>的抽象数据类型

ADT Array{

​	数据对象： j~i~ = 0,······,b~i~-1	i = 1,2,······n				n为数组的维数，b~i~为数组第i维的长度

​						D = {a~j1j2······jn~|a~j1j2······jn~ ∈ElemSet}

​	数据关系：

​						R1 = {<a~j1······ji······jn~，a~j1······ji+1······jn~>|0<=j~k~<=b~k~-1 , 1<=k<=n, 且k≠i, 0<=j~i~<=b~k~-2,

​									<a~j1······ji······jn~，a~j1······ji+1······jn~>∈D ,i = 2,······,n}

}



基本操作

```
1.InitArray(&A,n,bound1,...boundn)		//n是维数，boundn是每一维的上界
2.DestoryArray(&A)
3.Value(A,&e,index1,...indexn)
4.Assign(A,&e,index,...indexn)
}ADT Array
```



### 数组的顺序存储

数组特点：结构固定

数组基本操作：初始化、销毁、取元素、修改元素值。一般不做插入和删除操作

<font color="red">所以：</font>一般都是用<font color="blue">顺序存储结构</font>来表示数组

注意：数组可以是多维的，但是存储数据元素的内存地址单元是一维的



**一维数组**

​					LOC(0) = a							i = 0

LOC（i）=  

​					LOC(i-1) + L = a + i * L,		i > 0



**二维数组**

两种存储方式：

1. 以行序为主序		LOC( i , j ) = LOC ( 0 , 0 ) + ( n * i  + j ）* L 			n列数  m行数
2. 以列序为主序        LOC( i , j ) = LOC ( 0 , 0 ) + ( i + j * m ) * L 



**三维数组**

按 页/行/列 存放，页优先的顺序存储

a[m1] [m2] [m3] 各维元素个数为m1,m2,m3

下标为i~1~,i~2~,i~3~的数组元素的存储位置

LOC ( i~1~,i~2~,i~3~ ) = a + i~1~ * m2 * m3 + i~2~ * m3 + i~3~





### 特殊矩阵的压缩存储

矩阵的常规存储：描述为二维数组

矩阵的常规存储的特点：可以随机存取；运算简单；存储密度为1

不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多

矩阵的压缩存储：为多个相同的非零元素只分配一个空间；对零元素不分配空间

1. 什么是压缩存储

   若多个数据元素的<font color="red">值都相同</font>，则只分配一个元素值的存储空间，且零元素不占存储空间

2. 什么样的矩阵能够压缩

   一些特殊矩阵，如：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵等

3. 什么叫稀疏矩阵

   矩阵中非零元素很少（一般少于5%）



#### 对称矩阵

**特点：**对角线上下两边都对称，即a~ij~ = a~ji~  (1<=i,j<=n)

**存储方法：**只存储上（或下）三角（包括主对角线）的元素，占用 n(n+1)/2 的存储空间

**存储结构：**

可以<font color="red">以行序为主序</font>将元素存储在一维数组 sa[ n(n+1)/2 ]中

一维数组中的元素，它前面有多少个元素它就在第几个位置

假如求 a~ij~ 在一维数组中的位置   ( i - 1 + 1) *( i-1)/2  +  j - 1	（下三角）



#### 三角矩阵

**特点：**对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c

**存储方法：**重复元素c共享一个元素存储空间，共占用 n(n+1)/2 + 1 个元素空间

​					类似于对称矩阵



#### 对角矩阵

**特点：**所有元素都集中在以主对角线为中心的带状区域中，区域外的值为0，称为<font color="red">对角矩阵</font>

**存储方法：**用二维数组存储，每一个对角线上的所有元素存储为一行

|      |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  -2  |      |      |  3   |  3   |  8   |  5   |
|  -1  |      |  2   |  0   |  6   |  1   |  2   |
|  0   |  8   |  2   |  7   |  9   |  4   |  3   |
|  1   |  4   |  7   |  6   |  1   |  8   |      |
|  2   |  5   |  9   |  6   |  2   |      |      |

其中主对角线存储在行标为0的行中



#### 稀疏矩阵

三元组法：三元组（i，j，a~ij~）唯一确定矩阵的一个非零元

矩阵由所有三元组和矩阵维数（m，n）唯一确定

**压缩存储原则：**存各非零元的值、行列位置和矩阵的行列数



1、顺序存储结构：三元组顺序表

|      | i（行数） |  j（列数）  |     v（元素值）     |
| :--: | :-------: | :---------: | :-----------------: |
|  0   | 6(总行数) | 6（总列数） | 8（非零元素总个数） |
|  1   |     1     |      2      |         12          |
|  2   |     1     |      3      |          9          |
|  3   |     3     |      1      |         -3          |

三元组顺序表又称<font color="red">有序的双下标法</font>

优点：非零元在表中按行序有序存储，因此<font color="red">便于进行依行顺序处理的矩阵运算</font>

缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始查找



2.链式存储结构：十字链表

优点：能够<font color="red">灵活地插入</font>因运算而产生的新的非零元素，<font color="red">删除</font>因运算产生的新的零元素，实现矩阵的各种运算。

表示：每一个非零元素用一个结点表示，该结点有五个域（row，col，value，right，down）

right：用于链接同一行中的下一个非零元素

down：用于链接同一列中的下一个非零元素

| 头结点  | M.chead |      |      |      |
| :-----: | :-----: | :--: | :--: | :--: |
| M.rhead |  结点   |      |      | 结点 |
|         |         | 结点 |      |      |
|         |  结点   |      |      |      |







## 广义表

广义表（又称列表List）是n个元素的有限序列，其中每一个a~i~或者是<font color="red">原子</font>或者是一个<font color="red">广义表</font>

拓宽了的线性表就是广义表。



### 广义表的定义

* 广义表通常记作：LS = （a~1~,a~2~,……,a~n~）

​	其中：LS为表名，n为表的长度，每一个a~i~为表的元素

* 习惯上，一般用大写字母表示广义表，小写字母表示原子
* 表头：若LS非空，则其第一个元素a~1~就是表头，记作head（LS） = a~1~ <font color="red">注：</font>表头可以是原子或子表
* 表尾：除表头之外<font color="red">其他元素</font>组成的表，记作tail（LS） = （a~2~,……,a~n~） <font color="red">注：</font>表尾不是最后一个元素，而是一个子表



### 广义表的性质

1. 广义表中的数据元素有相对 <font color="red">次序</font>；一个直接前驱和一个直接后继
2. 广义表的<font color="red">长度</font>定义为最外层所包含元素的个数
3. 广义表的<font color="red">深度</font>定义为该广义表 <font color="blue">展开后所含括号的重数；</font>  <font color="red">注：</font>“原子”的深度为0；“空表”的深度为1
4. 广义表可以为其他广义表<font color="red">共享</font>
5. 广义表可以是一个 <font color="red">递归</font>的表。<font color="red">注：</font>递归表的深度是无穷值，长度是有限值
6. 广义表是<font color="red">多层次</font>结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表



### 广义表和线性表的区别

广义表可以看成是线性表的推广，线性表是广义表的特例

广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、数和有向图等各种常用的数据结构



### 广义表的基本运算

1. 求表头GetHead（L)，可以是一个原子也可以是一个子表
2. 求表尾GetTail（L)，一定是一个子表



### 广义表的存储

因为表中元素的大小不固定，所以不用数组存储，一般用链表存储





## ⛄树和二叉树

### 树的定义

树（Tree）是n（n>=0）个结点的有限集（递归定义）。

若n=0，称为空树；

若n>0，则它满足如下两个条件：

	1. 有且仅有一个特定的称为 根 的结点
	2. 其余结点可以分为m个互不相交的有限集T1，T2，T3······Tm，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）
	3. 





### 树的基本术语

结点：数据元素以及指向子树的分支

根节点：非空树中无前驱结点的结点

结点的度：结点拥有的子树数

树的度：树内各结点的度的最大值

叶子结点：度为0，也叫作终端节点

分支结点：度不为0，非终端结点

内部结点：根节点以外的分支结点

结点的子树称为该结点的<font color="red">孩子</font>，该结点称为孩子的<font color="red">双亲</font>

拥有同一个双亲的结点称为<font color="red">兄弟结点</font>

双亲在同一层但双亲不同的结点称为<font color="red">堂兄弟结点</font>

结点的<font color="red">祖先</font>：从根到该结点所经分支上的所有结点

结点的<font color="red">子孙</font>：以某结点为根的子树中的任一结点

树的<font color="red">深度</font>：树中结点的最大层次

<font color="red">有序树：</font>树中结点的各子树从左至右有次序（最左边为第一个孩子）

<font color="red">无序树：</font>树中结点的各子树无次序

<font color="red">森林：</font>是m（m>=0)棵互不相交的树的集合，根结点删除就变成了森林，给森林中的各子树加上一个双亲结点，森林就变成了树





### 二叉树的定义

为什么要研究二叉树？

答：二叉树结构最简单，规律性最强；可以证明，所有树都能转为唯一对应的二叉树，不失一般性；普通树若不转换为二叉树，则运算很难实现。二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以与二叉树相互转换，这就解决了树的存储结构及其运算中存在的复杂性。



**定义**

二叉树是n（n>=0）个结点的有限集，它或者是空集，或者由一个<font color="blue">根结点</font>及<font color="red">两个互不相交</font>的分别称作这个根的<font color="blue">左子树</font>和<font color="blue">右子树</font>的二叉树组成。



**特点**

1. 每个结点最多有两个孩子<font color="red">（二叉树中不存在度大于2的结点）</font>
2. 子树有左右之分，其次序不能颠倒
3. 二叉树可以是空集合，根可以有空的左子树或空的右子树



<font color="red">注：</font>二叉树不是树的特殊情况，它们是两个概念。二叉树的子树要区分左子树和右子树，即使只有一个子树也要区分；而当树的结点只有一个孩子时，就无须区分它是左还是右的次序。这是两者之间最大的差别。



### 二叉树的抽象数据类型定义

**二叉树的抽象数据类型定义**

```
ADT BinaryTree{
	数据对象D：D是具有相同特性的数据元素的集合
	数据关系R：若D=∅，则R=∅
			  若D≠∅，则R={H},H是如下二元关系
			  1. root唯一//关于根的说明
			  2. ......//子树不相交
			  3. ......//关于数据元素的说明
			  4. ......//关于左子树和右子树的说明
	基本操作P：//至少有20个
}ADT BinaryTree
```

**比较重要的几个操作：**

```
CreateBiTree(&T,definition)
	初始条件：definition给出二叉树T的定义	//definition是指构造方式（先序...)
	操作结果：按definition构造二叉树T
PreOrderTraverse(T)
	初始条件：二叉树T存在
	操作结果：先序遍历T，对每个结点访问一次
InOrderTraverse(T)
	初始条件：二叉树T存在
	操作结果：中序遍历T，对每个结点访问一次
PostOrderTraverse(T)
	初始条件：二叉树T存在
	操作结果：后序遍历T，对每个结点访问一次
```





### 二叉树的性质

<font color="red">性质1：</font>在二叉树的第i层上<font color="blue">最多</font>有2^i-1^个结点（i>=1）

<font color="red">性质2：</font>深度为k的二叉树<font color="blue">最多</font>有2^k^-1个结点（k>=1）	<font color="red">深度为k时至少有k个结点</font>

<font color="red">性质3：</font>对任意一颗二叉树T，如果其叶子数为n~0~，度为2的结点数为n~2~，则<font color="red">n~0~=n~2~+1</font>

从下往上：结点数为n，总边数为B，则有B = n-1（除了根节点每个结点都与双亲有一条连线）

从上往下：B = n~2~ * 2 + n~1~ * 1

B = n~2~ * 2 + n~1~ * 1 =  n - 1

n = n~2~ * 2 + n~1~ * 1 + 1

又因为n = n~0~ + n~1~ + n~2~	两式相结合得到 n~0~=n~2~+1



**两种特殊形式的二叉树**

**满二叉树**

一颗深度为k且有2^k^-1个结点的二叉树称为<font color="blue">满二叉树</font>

特点：1. 每层都满	2. 叶子结点全部在最底层

对满二叉树结点位置进行编号：从根结点开始，从上至下，从左至右。每一结点位置都有元素。

* 满二叉树在同样深度的二叉树中<font color="red">结点</font>个数最多
* 满二叉树在同样深度的二叉树中<font color="red">叶子结点</font>个数最多



**完全二叉树**

深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号为1~n的结点<font color="red">一一对应</font>时，称为完全二叉树

注：在满二叉树中，从最后一个结点开始<font color="red">连续</font>去掉<font color="red">任意</font>个结点，即是一棵完全二叉树

特点：1. 叶子只可能分布在层次最大的两层上

​			2. 对任一结点，如果其右子树的最大层数为i，则其左子树的最大层数为i或者i+1



<font color="red">性质4：</font>具有n个结点的完全二叉树的深度为⌊ log~2~n ⌋ + 1		(完全二叉树结点n与深度k的关系)

<font color="red">性质5：</font>如果对一颗有n个结点的完全二叉树的结点按层序编号（从第1层到第⌊ log~2~n ⌋ + 1层，每层从左到右），则对任一结点i（1<=i<=n），有

1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其<font color="red">双亲结点是⌊ i / 2 ⌋</font>
2. 如果2i>n，则结点i为叶子结点，无左孩子；否则，其<font color="red">左孩子结点是2i</font>
3. 如果2i + 1>n，则结点i无右孩子；否则，其<font color="red">右孩子结点是2i+1</font>

性质5表明了完全二叉树中<font color="red">双亲结点编号</font>与<font color="red">孩子结点编号</font>之间的关系

<font color="red">性质6：</font>





### 二叉树的存储结构

#### 二叉树的顺序存储

按<font color="red">满二叉树</font>的结点层次编号，依次存放二叉树中的数据元素

```c++
//二叉树顺序存储表示
#define MAXTSIZE 100
typedef TElemType SqBiTree[MAXSIZE];	//定义了一种数组类型，元素类型TElemType
SqBiTree bt;
```

若二叉树不是完全二叉树，也同样存储，没有元素的结点就空着，存0

二叉树的顺序存储缺点：

最坏情况：深度为k且只有k个结点的单支树需要长度为2^k^-1的一维数组

结点间关系蕴含在其存储位置中，浪费空间，适于存<font color="red">满二叉树和完全二叉树</font>



#### 二叉树的链式存储结构

二叉链表存储结构

```
typedef struct BiNode{
	TElemType data;
	struct BiNode *lchild,*rchild;	//左右孩子指针
}BiNode,*BiTree;
```



在n个结点的二叉链表中，必有<font color="red">2n</font>个链域。除根结点外，每个结点有且仅有一个双亲，所以会有<font color="red">n-1</font>个结点的链域存放指针，指向非空子女结点。所以，在n个结点的二叉链表中

<font color="red">空指针数目= 2n - (n-1) = n +1</font>



#### 三叉链表

三个指针域：lchild、rchild、parent

```c++
typedef struct TriTNode{
    TElemType data;
    struct TriTNode *lchid,*rchild,*parent;
}TriTNode,*TriTree;
```





### 遍历二叉树

<font color="red">遍历：</font>顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。[“访问”的含义很广，可以是对结点做各种处理，如：输出结点信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构]

<font color="red">遍历目的：</font>得到树中所有结点的一个线性排列

<font color="red">遍历用途：</font>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心



#### 遍历二叉树算法描述

**遍历方法**

若规定**先左后右**，则只有三种情况：

DLR - 先序遍历

LDR - 中序遍历

LRD - 后序遍历

|        先序遍历二叉树        |        中序遍历二叉树        |        后序遍历二叉树        |
| :--------------------------: | :--------------------------: | :--------------------------: |
| 若二叉树为空，则空操作；否则 | 若二叉树为空，则空操作；否则 | 若二叉树为空，则空操作；否则 |
|         1.访问根结点         |       1.中序遍历左子树       |       1.后序遍历左子树       |
|       2.先序遍历左子树       |         2.访问根结点         |       2.后序遍历右子树       |
|       3.先序遍历右子树       |       3.中序遍历右子树       |         3.访问根结点         |



#### 根据遍历序列确定二叉树

* 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的
* 由二叉树的<font color="red">先序序列和中序序列</font>，或由二叉树的<font color="red">后序序列和中序序列</font>可以确定唯一一颗二叉树



**已知先序和中序序列求二叉树**

分析：由先序序列确定根，由中序序列确定左右子树



**已知中序和后序序列求二叉树**

分析：由后序序列确定根，由中序序列确定左右子树





#### 遍历的算法实现

##### 先序遍历

存储结构：二叉链表

方法：递归

```c++
Status PreOrderTraverse(BiTree T){		//递归后传递进来的就是T->child的值了
	if(T==NULL) return OK;
	else{
		visit(T);	//访问根结点	例如，输出根结点：cout<<T->data;
		PreOrderTraverse(T->lchild);	//递归遍历左子树
		PreOrderTraverse(T->rchild);	//递归遍历右子树
	}
}
```

```c++
void Pre(BiTree T){			//例子
	if(T!=NULL){
		cout<<T->data;
		pre(T->lchild);
		pre(T->rchild);
	}
}
```





##### 中序遍历

```c++
Status InOrderTraverse(BiTree T){	//中序遍历
	if(T==NULL) return OK;
    else{
        InOrderTraverse(T->lchild);
        visit(T);
        InOrderTraverse(T->rchild);
    }
}
```



##### 后序遍历

```c++
Status PostOrderTraverse(BiTree T){	//后序遍历
	if(T==NULL) return OK;
	else{
		PostOrderTraverse(T->lchild);
		PostOrderTraverse(T.>rchild);
		visit(T);
	}
}
```



#### 遍历算法的分析

如果去掉输出语句，从递归的角度看，三种算法是完全相同得分，或者说着三种算法的访问路径是相同的，只是访问节点的时机不同。

第1次经过时访问 = 先序遍历

第2次经过时访问 = 中序遍历

第3次经过时访问 = 后序遍历



时间复杂度O（n）	//每个结点只访问一次

空间复杂度O（n）	//栈占用的最大辅助空间（都是左子树或者都是右子树）



#### 遍历二叉树的非递归算法

##### 中序遍历非递归算法

关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树

<font color="red">基本思想：</font>

1. 建立一个<font color="red">栈</font>
2. <font color="red">根</font>结点<font color="red">进栈</font>，遍历<font color="red">左子树</font>
3. <font color="red">根</font>结点<font color="red">出栈</font>，输出根结点，遍历<font color="red">右子树</font>



```c++
Status InOrderTraver(BiTree T){		//T是根结点
    BiTree p; InitStack(S); p = T;	//p是当前要出栈或者入栈的结点
    while(p||!StackEmpty(S)){
        if(p) {push(S,p); p = p->lchild;}
        else  {pop(S,q); cout<<q->data; p = q->rchild;}	//q是栈顶元素
    }
    return OK;
}
```



#### 二叉树的层次遍历

对于一颗二叉树，从根结点开始，按<font color="red">从上到下、从左到右</font>的顺序访问每一个结点。每个结点仅访问一次。

实现的关键：<font color="red">顺序循环队列</font>

队列类型定义如下

```c++
typedef struct{
	BTNode data[MAXSIZE];	//存放队中元素
	int front, rear;		//队头和队尾指针
}SqQueue;
```

层次遍历算法

```c++
void LevelOrder(BTNode &b){
	BTNode *p; SqQueue *qu;	p = b;
	InitQueue(qu);				//初始化队列
	enQueue(qu,b);				//根结点指针进入队列
	while(!QueueEmpty(qu)){		//队不为空，则循环
		deQueue(qu,p);			//出队结点p（应该是队首元素）
		cout<<p->data;			//访问结点p
		if(p->lchild != NULL) enQueue(qu,p->lchild);	//有左孩子时将其进队
		if(p->rchild !=NULL) enQueue(qu,p->rchild);		//有右孩子时将其进队
	}
}
```



#### 二叉树的建立

**按先序遍历建立二叉树的二叉链表**

例：ABCDEGF	如果只这么输入，树不是唯一的，所以<font color="red">空结点用其他符号表示</font>

```c++
Status CreateBiTree(BiTree &T){
	char ch;
    cin>>ch;
    if(ch == '#') T == NULL;
    else{
        if(!(T = new BiTNode)) exit(OVERFLOW);
        T->data = ch;				//生成根结点
        createBiTree(T->lchild);	//构造左子树
        createBiTree(T->rchild);	//构造右子树
    }
    return OK;
}
```



#### 复制二叉树

**先序遍历复制二叉树**

* 如果是空树，递归结束；
* 否则，申请新结点空间，复制根结点
  * 递归复制左子树
  * 递归复制右子树

```c++
int Copy(BiTree, BiTree &NewT){
	if(BtTree == NULL){
		NewT = NULL; return 0;	//如果是空树返回0
	}
	else{
		NewT = new BiTNode;		//内存中申请一块新结点空间
		NewT->data = T->data;	//将data域中的值复制到新结点当中
		Copy(T->lchild, NewT->lchild);	//递归复制左子树
		Copy(T->rchild, NewT->rchild);	//递归复制右子树
	}
}
```





#### 计算二叉树深度

* 如果是空树，深度为0
* 否则，递归计算左子树的深度为m，递归计算右子树的深度为n，二叉树的深度为m和n的较大者加1

```c++
int Depth(BiTree){
	if(T == NULL) return 0;
	else{
		m = Depth(T->lchild);
		n = Depth(T->rchild);
		return m>n?m+1:n+1;
	}
}
```





#### 计算二叉树结点总个数

* 如果是空树，则结点个数为0
* 否则，结点个数为左子树结点个数+右子树结点个数+1（根结点）

```c++
int NodeCount(BiTree T){
	if(T == NULL) return 0;
	else return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;
}
```





#### 计算二叉树叶子结点树

* 如果是空树，叶子结点个数为0
* 否则，为左子树的叶子结点树+右子树的叶子结点数

```c++
int LeafCount(BiTree T){
	if(T == NULL) return 0;		//如果是空树返回0
	if(T->lchild == NULL && T->rchild == NULL) return 1; //如果是叶子结点返回1
	else return LeafCount(T->lchild)+LeafCount(T->rchild);
}
```







### 线索二叉树

**为什么要研究线索二叉树**？

当用二叉链作为存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，<font color="red">无法直接找到该结点在某种遍历序列中的前驱和后继结点</font>



**如何寻找特定遍历序列中二叉树结点的前驱和后继？**

解决方法：

1. 通过遍历寻找						费时间
2. 添加前驱、后继指针域         费空间
3. <font color="red">利用二叉链表的空指针域</font>



**二叉链表中空指针域的数量**

n个结点的二叉树有2n个指针域，n个结点中有<font color="red">n-1</font>个孩子，即在2n个指针域中，有n-1个用来指示结点的左右孩子，其余 2n - (n-1) = <font color="red">n + 1 个指针域为空</font>



**利用二叉链表中的空指针域**

如果某个结点的左孩子为空，则将空的左孩子指针域改为<font color="red">指向其前驱</font>；如果某结点的右孩子为空，则将空的右孩子的指针域改为<font color="red">指向其后继</font>

这种<font color="red">改变指向的指针</font>称为<font color="red">“线索”</font>

加上了线索的二叉树称为<font color="red">线索二叉树</font>

对二叉树按某种遍历次序使其变为线索二叉树的过程叫做<font color="red">线索化</font>





**区分孩子指针和前驱后继指针**

为了区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中<font color="red">每个结点增设两个标志域 ltag 和 rtag</font>

ltag = 0	lchild指向该结点的左孩子

ltag = 1	lchild指向该结点的前驱

rtag = 0	rchild指向该结点的右孩子

rtag = 1	rchild指向该结点的后继



#### 结点的结构

```c++
typedef struct BiThrNode{
	int data;
    int ltag,rtag;
    struct BiThrNode *lchild,*rchild;
}BiThrNode,*BiThrTree;
```



#### **增加一个头结点**

为了防止指针域悬空态，增加一个头结点，指针域为空的指向头结点

ltag=0，lchild指向根结点

rtag=1，rchild指向遍历序列中的最后一个结点

遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点







### 树和森林

#### 树的存储结构

##### 1.双亲表示法

实现：定义数据结构，每个结点含两个域

数据域：存放结点本身信息

双亲域：指示本结点的双亲结点在数组中的位置

r = 0  根结点位置	n = 10 结点数，方便定义数组

特点：找双亲容易，找孩子难



**结点的类型定义**

结点结构：

```c++
typedef struct PTNode{
	TElemType data;
	int parent;
}PTNode;
```

树结构：

```c++
#define MAX_TREE_SIZE 100
typedef struct{
	PTNode nodes[MAX_TREE_SIZE];
	int r,n;
}PTree;
```





##### 2.孩子链表

把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。

则n个结点有n个孩子链表（叶子的孩子链表为空表）。

而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。

特点：找孩子容易，找双亲难



**类型定义**

孩子结点结构

```c++
typedef struct CTNode{
	int child;
	struct CTNode *next;
}*ChildPtr;
```

双亲结点结构

```c++
typedef struct {
	TElemType data;
	ChildPtr firstchild;	//孩子链表头指针
}CTBox;
```

树结构

```c++
typedef struct {
	CTBox nodes[MAX_TREE_SIZE];
	int n,r;	//结点数和根结点的位置
}CTree;
```



为了方便操作，可以在数据域中再增加一个双亲的下标位置。<font color="red">带双亲的孩子链表。</font>





##### 3.孩子兄弟表示法

实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其<font color="red">第一个孩子结点</font>和<font color="red">下一个兄弟结点</font>

```c++
typdedef struct CSNode{
	ElemType data;
	struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

特点：查找孩子容易，查找双亲难





####  树与二叉树的转换

将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作

由于树和二叉树都可以用二叉链表作存储结构，则<font color="red">以二叉链表作媒介</font>可以导出树与二叉树之间的一个对应关系

<font color="red">给定一颗树，可以找到唯一的一棵二叉树与之对应</font>

 

**将树转换成二叉树**

1.加线：在兄弟之间加一条线

2.抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系

3.旋转：以树的根结点为轴心，将整树顺时针转45°



**将二叉树转换成树**

1.加线：若p结点是双亲结点的左孩子，则将p的有孩子，有孩子的有孩子……延分支找到所有的右孩子，都与p的双亲用线连起来

2.抹线：抹掉原二叉树中双亲与右孩子之间的连线

3.调整：将结点按层次排列，形成树结构





#### 森林与二叉树的转化

**森林转化成二叉树**

1.将各棵树分别转换成二叉树

2.将每棵树的根节点用线相连

3.以第一棵树根节点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构



**二叉树转化成森林**

1.抹线：将二叉树根结点与其右孩子连线，及沿右分支搜索到的所有右孩子建连线全部抹掉，使之变成孤立的二叉树

2.还原：将孤立的二叉树还原成树



#### 树和森林的遍历

**1.树的遍历（三种方式）**		 【二叉树的遍历有四种方式：先根、中根、后根、层次】

* 先根遍历：

  若树不空，则先访问根结点，然后依次先根遍历各棵子树

* 后根遍历：

  若树不空，则先依次后根遍历各棵子树，然后访问根结点

* 参差遍历：

  若树不空，则自上而下从左至右访问树中每个结点 



**2.森林的遍历**

将森林看做有三部分构成：

1.森林中第一棵树的根结点；

2.森林中第一棵树的子树森林；

3.森林中其他树构成的森林



**先序遍历：**

若森林不空，则

1.访问森林中第一棵树的根结点；

2.先序遍历森林中第一棵树的子树森林；

3.先序遍历森林中（除第一棵树之外）其余树构成的森林

<font color="red">即：依次从左至右对森林中每一棵树进行先根遍历</font>

<font color="red">还有一种很简单的方法：即对森林中每一棵树依次进行先序遍历</font>



**中序遍历：**

若森林不空，则

1.中序遍历森里中第一棵树的子树森林；

2.访问森林中第一棵树的根结点；

3.中序遍历森林中（除第一棵树之外）其余树构成的森林

<font color="red">即：依次从左至右对森林中每一棵树进行中序遍历</font>

  





### 哈夫曼树及应用

#### 哈夫曼树的基本概念

<font color="red">判断树：</font>用于描述分类过程的二叉树

路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径

路径的长度：两结点间路径上的分支数

树的路径长度：从<font color="red">树根</font>到每一个结点的<font color="red">路径长度之和</font>。记作：TL

<font color="red">结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</font>路径长度最短的不一定是二叉树。

权（weight）：将树中结点赋给一个有着某种含义的数值，则这个数值称为该<font color="red">结点的权</font>

结点的带权路径长度：从<font color="red">根结点</font>到该结点之间的<font color="red">路径长度</font>与该结点的<font color="red">权</font>的<font color="red">乘积</font>

树的带权路径长度：树中所有<font color="red">叶子</font>结点的<font color="red">带权路径长度</font>。记作：WPL (Weighted Path Length)



哈夫曼树：<font color="red">最优树</font> 即带权路径长度最短的树

“带权路径长度最短”是在“度相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。

哈夫曼树：<font color="red">最优二叉树</font> 带权路径长度最短的二叉树

相应的算法称为哈夫曼算法



特点：

满二叉树不一定是哈夫曼树

哈夫曼树中权越大的叶子离根越近

具有相同带权结点的哈夫曼树不唯一



#### 哈夫曼树的构造算法

贪心算法：构造哈夫曼树时首先选择权值小的叶子结点

<font color="red">哈夫曼算法</font>

1.根据n个给定的权值{w~1~,w~2~,…,w~n~}构成n棵二叉树的森林F={T~1~,T~2~,…,T~n~},其中T~i~只有一个带权为w~i~的根结点

<font color="red">构造森林全是根</font>

2.在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右字数上根结点的权值之和

<font color="red">选用两小造新树</font>

3.在F中删除这两棵树，同时将新得到的二叉树加入森林中

<font color="red">删除两小添新人</font>

4.重复2和3，直到森林中只有一棵树为止，这棵树即为哈夫曼树

<font color="red">重复2、3剩单根</font>



哈夫曼树的结点度数为0或2，没有度为1的结点

包含n个叶子结点的哈夫曼树中共有2n-1个结点

（包含n棵树的森林要经过n-1次和并才能形成哈夫曼树，共产生n-1个新结点）



**总结：**

1.在哈夫曼算法中，初始时有n棵二叉树，要经过<font color="red">n-1</font>次合并最终形成哈夫曼树

2.经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支节点

可见：哈夫曼树中共有 n+n-1 =  <font color="red">2n-1</font>个结点，且其所有的分支结点的度均不为1





#### 哈夫曼树构造算法的实现

采用顺序存储结构————一维结构数组

结点类型定义

```c++
typedef struct{
	int weight;
	int parent,lch,rch;
}HTNode,*Huffman Tree;
```

| 哈夫曼树中结点下标i | weight | parent | lch  | rch  |
| :-----------------: | :----: | :----: | :--: | :--: |
|          1          |        |        |      |      |
|          2          |        |        |      |      |
|          3          |        |        |      |      |
|          …          |        |        |      |      |
|        2n-1         |        |        |      |      |

哈夫曼树中共有2n-1个结点，不使用0下标，数组大小为2n



步骤：

1.初始化<font color="red">HT[1……2n-1]</font> : lch = rch = parent = 0;

2.输入初始<font color="red">n个叶子结点</font>：置HT[1……n]的<font color="red">weight值</font>

```c++
void CreateHuffmanTree(HuffmanTree HT,int n){ //构造哈夫曼树--哈夫曼算法
	if(n<=1) return;
	m = 2*n - 1;	//数组共2n-1个元素
	HT = new HTNode[m+1];	//0号单元未用，HT[m]表示根结点
	for(i=1;i<=m;i++){
		HT[i].lch = 0;HT[i].rch = 0;HT[i].parent = 0;
	}
	for(i=1;i<=n,++i) cin>>HT[i].weight;	//输入前n个元素的weight值
	//初始化结束，下面开始建立哈夫曼树
续
```

3.<font color="red">进行以下n-1次合并，</font>依次产生n-1个结点HT[i], i=<font color="red">n+1</font>…..2n-1;

 	a.在HT[1…i-1]中选两个<font color="red">未被选过</font>（从parent==0的结点中选）的weight最小的两个结		点<font color="red">HT[s1]</font>和<font color="red">HT[s2]</font>,<font color="red">s1、s2为两个最小结点下标</font>

​	b.修改HT[s1]和HT[s2]的parent值：HT[s1].parent = i; HT[s2].parent = i;

​	c.修改新产生的HT[i]：

​		HT[i].weight = HT[s1].weight + HT[s2].weight;

​		HT[i].lch = s1; HT[i].rch = s2;

```c++
续
for(i=n+1;i<=m;i++){		//合并产生n-1个结点--构造Huffman树
	Select(HT,i-1,s1,s2);	//在HT[k](1<=k<=i-1)中选择两个其双亲域为0
							//且权值最小的结点，并返回它们在HT中的序号s1和s2
	HT[s1].parent = i; HT[s2].parent = i;	//表示从F中删除s1,s2
    HT[i].lch = s1; HT[i].rch = s2;			//s1，s2分别作为i的左右孩子
    HT[i].weight = HT[s1].weight+HT[s2].weight;//i的权值为左右孩子权值之和
}
}
```





#### 哈夫曼编码

在远程通讯中，要将待传字符转换成由二进制的字符串

若将编码设计为长度不等的二进制编码，即让待传字符串中<font color="red">出现次数较多的字符采用尽可能短的编码，</font>则转换的二进制字符串便可能减少

<font color="red">关键：</font>要设计长度不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀

这种编码称作<font color="red">前缀编码</font>



问题：什么样的前缀码能使电文总长最短  ----<font color="red">哈弗曼编码</font>

1.<font color="red">统计</font>字符集中<font color="red">每个字符</font>在电文中<font color="red">出现的</font>平均<font color="red">概率</font>（概率越大，要求编码越短）。

2.利用哈夫曼树的特点：权越大的叶子离根越近；<font color="red">将每个字符的概率值作为权值，构造哈夫曼树。</font>则概率越大的结点，路径越短。

3.在哈夫曼树的每个分支上标上0或1：

​	结点的<font color="red">左分支标0，右分支标1</font>

​	把根到每个叶子的路径上的标号连接起来，作为该叶子代表的<font color="red">字符的编码</font>



**为什么哈弗曼编码能够保证是前缀编码？**

因为没有一片树叶是另一片树叶的祖先，所以每个叶子结点的编码就不可能是其他叶子结点编码的前缀



**为什么哈弗曼编码能够保证字符编码总长最短**

因为哈夫曼树的带权路径长度最短，故字符编码的总长最短



<font color="red">哈夫曼编码的两个性质</font>

1.哈弗曼编码是前缀码

2.哈夫曼编码是最优前缀码



#### 哈夫曼编码的算法实现

```c++
void CreateHuffmanCode(Huffman Tree HT,HuffmanCode &HC,int n){
//从叶子到根逆向求每个字符的哈弗曼编码，存储在编码表HC中
	HC = new char *[n+1];	//分配n个字符编码的头指针矢量
	cd = new char[n];		//分配临时存放编码的动态数组空间
	cd[n-1] = '\0';			//编码结束符 （字符串结束符）
	
	for(i=1;i<=n;++i){
		start=n-1;c=i;f=Ht[i].parent;
		while(f!=0){	//从叶子结点开始向上回溯，直到根结点
			--start;	//回溯一次start向前指一个位置
			if(HT[f].lchild == c) cd[start]='0'; //结点c是f的左孩子，0
			else cd[start]='1';					 //结点c是f的右孩子，1
			c = f; f = HT[f].parent;			 //继续向上回溯
		}	//求出第i个字符的编码
		HC[i] = new char[n-start];		//为第i个字符串编码分配空间大小是
        								// n-start 已占用的空间量
		strcpy(HC[i],&cd[start]);		//将求得的编码从临时空间cd复制到HC的当前行中
	}
	delete cd;	//释放临时空间
}
```





#### 文件的编码和解码

**编码**

1.输入各字符及其权值

2.构造哈夫曼树--HT[i]

3.进行哈夫曼编码--HC[i]

4.查HC[i]，得到各字符的哈弗曼编码



**解码**

1.构造哈夫曼树

2.依次读入二进制码

3.读入0，则走向左孩子；读入1，则走向右孩子

4.一旦达到某叶子时，即可译出字符

5.然后再从根出发继续译码，直到结束









## 图

### 图的定义和基本术语

图：G=(V,E)				Graph = （Vertex , Edge)

​		V：顶点（数据元素）的有穷非空集合；

​		E：边的有穷集合



无向图：每条边都是无方向的

有向图：每条边都是有方向的

完全图：任意两个点都有一条边相连（无向完全图和有向完全图，其中有向完全图要两个方向都有边）



无向完全图：<font color="red">n个顶点，n(n-1)/2条边</font>

有向完全图：<font color="red">n个顶点，n(n-1)条边</font>



稀疏图：有很少边或弧的图（e < nlog~n~）

稠密图：有较多边或弧的图

网：边/弧带权的图

邻接：有边/弧相连的两个顶点之间的关系

​			存在（v~i~ , v~j~）, 则称v~i~ 和 v~j~互为邻接点

​			存在 <v~i~ , v~j~> , 则称 v~i~ 邻接到 v~j~ ，v~j~ 邻接于 v~i~ 

​			圆括号表示无向图，尖括号表示有向图，从前面到后面

关联（依附）：边/弧与顶点之间的关系

​							存在（v~i~ , v~j~） / <v~i~ , v~j~> , 则称该边/弧关联于v~i~ 和v~j~

顶点的度：与该顶点相关联的边的数目，记为TD(v)

​					在<font color="red">有向图</font>中，顶点的度等于该顶点的<font color="red">入度</font>和<font color="red">出度</font>之和

​					顶点<font color="red">v的入度</font>是以v为终点的有向边的条数，记作ID(v)

​					顶点<font color="red">v的出度</font>是以v为始点的有向边的条数，记作OD(v)

路径：接续的边构成的顶点序列

路径长度：路径上边或弧的数目/权值之和

回路（环）：第一个顶点和最后一个顶点相同的路径

简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径

简单回路（简单环）：除路径起点和终点相同外，其余顶点均不相同的路径

连通图（强连通图）：在无（有）向图G = ( V , {E} )中，若对任何两个顶点v、u都存在从v到u的路径，则称G是<font color="red">连通图</font>（强连通图）。  

权与网：图中边或弧所具有的相关数称为<font color="red">权</font>。表面一个顶点到另一个顶点的距离或耗费（时间）。带权的图称为网。

子图：设有两个图G = ( V , {E} )，G1 = ( V , {E1} ) ， 若V1 属于V，E1属于E，则称G1是G的<font color="red">子图</font>。

连通分量（强连通分量）：无向图G的<font color="red">极大连通子图</font>称为G的<font color="red">连通分量</font>。

​					极大连通子图的意思是：该子图是G连通子图：将G的任何不在该子					图的顶点加入，子图不再连通。

​											   有向图G的<font color="red">极大连通子图</font>称为G的<font color="red">强连通分量</font>。

​					极大强连通子图的意思是：该子图是G强连通子图：将G的任何不在					该子图的顶点加 入，子图不再强连通。

极小连通子图：该子图是G的连通子图：在该子图中删除任何一条边，子图不再连通

生成树：包含无向图G所有顶点的极小连通图子图

生成森林：对非连通图，由各个连通分量的生成树的集合



### 图的类型定义

```
ADT Graph{
	数据关系V:具有相同特性的数据元素的集合，称为顶点集
	数据关系R:R={VR}
			VR = {（v,w）|<v,w>|v,w∈V ^ p(V,w)}
			<v,w>表示从v到w的弧，P(v,w)定义了弧<v,w>的信息
			
	基本操作：
		Create_Graph():图的创建操作
		Getvex(G,v):求图中顶点v的位置
		CreateGraph(&G,V,VR)
			初始条件：V是图的顶点集，VR是图中弧的集合
			操作结果：按V和R的定义构造图G
		DFSTraverse(G):对图进行深度优先遍历
		BFSTraverse(G):对图进行广度优先遍历
}ADT Graph
```





### 图的存储结构

图的逻辑结构：多对多

图没有顺序存储结构，但可以借助二维数组来表示元素间的关系，称为数组表示法（<font color="red">邻接矩阵</font>）

链式存储结构：多重链表：1、邻接表	2、邻接多重表	3、十字链表



#### 邻接矩阵

**数组（邻接矩阵）表示法**

建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间的关系）

设图A=(V,E)有n个顶点，则<font color="red">顶点表Vexs[n]</font>

|    i    |  0   |  1   |  2   |  …   | n-1  |
| :-----: | :--: | :--: | :--: | :--: | :--: |
| Vexs[i] | v~1~ | v~2~ | v~3~ |  …   | v~n~ |



**无向图的邻接矩阵表示法**

n*n的矩阵

<font color="red">邻接矩阵A.arcs[i] [j]</font>

|      |  v1  |  v2  |  v3  |  v4  |  v5  |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  v1  |      |      |      |      |      |
|  v2  |      |      |      |      |      |
|  v3  |      |      |      |      |      |
|  v4  |      |      |      |      |      |
|  v5  |      |      |      |      |      |

两个顶点间有关系填1，没有关系填0

分析1：对角线上都为0，该矩阵是一个对称矩阵

分析2：顶点i的<font color="red">度</font> = 第i行/列中<font color="red">1</font>的个数

<font color="red">特别：完全图的邻接矩阵中，对角线元素为0，其余都为1</font>



**有向图的邻接矩阵表示法**

n*n的矩阵

在有向图的邻接矩阵中，

​	第<font color="red">i</font>行含义：以结点V~i~为尾的弧（即出度边）；

​	第<font color="red">i</font>列含义：以结点V~i~为头的弧（即入度边）；



分析1：有向图的邻接矩阵<font color="red">可能是不对称</font>的

分析2：顶点的<font color="red">出度=第i行元素之和</font>

​			  顶点的<font color="red">入度=第i列元素之和</font>

​			  <font color="red">顶点的度=第i行元素+第i列元素之和</font>



**网（即有权图）的邻接矩阵表示法**

定义为：

A.arcs[i] [j] = W~ij~	<vi,vj>或(vi,vj)∈VR

​						∞	  无边（弧）



##### **邻接矩阵的存储表示**

 邻接矩阵的存储表示：用<font color="red">两个数组</font>分别存储<font color="red">定点表</font>和<font color="red">邻接矩阵</font>

```c++
#define MaxInt 32767	//表示极大值，即 ∞
#define MVNum 100		//最大顶点数
#typedef char VerTexType;	//设顶点的数据类型为字符型
#typedef int ArcType;		//假设边的权值类型为整型

typedef struct{
	VerTexType vex[MVNum];	//顶点表
	ArcType arcs[MVNum][MVNum];	//邻接矩阵
	int vexnum,arcnum;		//图的当前点数和边数
}AMGraph;	//Adjacency Matrix Graph
```



**采用邻接矩阵表示法创建无向网**

算法思想：

1.输入<font color="red">总顶点数和总边数</font>

2.依次输入<font color="red">点的信息存入定点表中</font>

3.<font color="red">初始化邻接矩阵</font>，使每个权值初始化为最大值

4.<font color="red">构造邻接矩阵</font>

```c++
Status CreateUDN(AMGraph &G){	//采用邻接矩阵表示法，创建无向网G
	cin>>G.vexnum>>G.arcnum;	//输入总顶点数，总边数
	for(i=0; i<G.vexnum; ++i)
		cin>>G.vex[i];			//依次输入点的信息
	for(i=0; i<G.vexnum; ++i)	//初始化邻接矩阵
		for(j=0; j<G.vexnum; ++j)
			G.arcs[i][j] = MaxInt;	//边的权值均置为极大值
	 
    for(k=0; K<G.arcnum; ++k){	//构造邻接矩阵
        cin>>v1>>v2>>w;			//输入一条边所依附的顶点及边的权值
        i = LocateVex(G,v1);
        j = LocateVex(G,v2);	//确定v1和v2在G中的位置
        G.arcs[i][j] = w;		//边的权值置位w
        G.arcs[j][i] = G.arcs[i][j];	//置对称边的权值为w
    }
	return OK;
}

//补充算法：在图中查找顶点
int LocateVex(AMGraph G,VertexType u){
//在图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1
    int i;
    for(i=0; i<G.vexnum; ++i){
        if(u == G.vex[i])	return i;
    }
    return -1;
}
```

* 无向图：边没有权值，初始化邻接矩阵时权值初始化为0，构造邻接矩阵时，w为1

* 有向网：邻接矩阵是非对称矩阵，仅为G.arcs[i] [j]赋值，无须为G.arcs[j] [i]赋值

* 有向网：同时进行无向图和有向图的修改



##### 邻接矩阵的优点和缺点

**优点：**

1.直观、简单、好理解

2.方便检查任意一对顶点间是否存在边

3.方便找任一顶点的所有“邻接点”（有边直接相连的顶点）

4.方便计算任一顶点的“度”



**缺点：**

1.不便于增加和删除结点

2.浪费空间：存稀疏图（点很多而边很少）有大量无效元素（0或者 ∞）

​	对稠密图（特别是完全图）还是很合算的

空间复杂度O(n^2^)

3.浪费时间：统计稀疏图中一共有多少条边





#### 邻接表

**1、邻接表表示法（链式）**

头结点：data	firstarc	当前顶点的值以及第一条弧的指针

表结点：adjvex	nextarc	(info) 邻接点的序号以及下一条边或弧(权值)

* 顶点：按编号顺序将顶点数据存储在<font color="red">一维数组</font>中；
* 关联同一顶点的边（以顶点为尾的弧）：用线性<font color="red">链表</font>存储



**无向图**

特点：

1.邻接表不唯一（邻接的顶点的顺序可以交换）

2.若<font color="red">无向图</font>中有n个顶点、e条边、则其邻接表需n个头结点和2e个表结点。适宜存储稀疏图。

空间复杂度O(n+2e)

3.无向图中顶点vi的度为第i个单链表中的结点数



**有向图**

特点：

1.顶点vi的**出度**为第i个单链表中的结点个数

2.顶点vi的**入度**为整个单链表中邻接点值域是i-1的结点个数

 （找出度容易，找入度难）

<font color="red">将链表中邻接点改成入度变成逆邻接表</font>

1.顶点vi的**入度**为第i个单链表中的结点个数

2.顶点vi的**出度**为整个单链表中邻接点值域是i-1的结点个数

(找入度容易，找出度 )

根据情况做选择



##### 邻接表的存储表示

```c++
//顶点的结点结构
//data	firstarc
typdef struct VNode{
	VerTexType data;	//顶点信息
	ArcNode * firstarc;	//指向第一条依附该顶点的边的指针
}VNode,AdjList[MVNum];	//AdjList表示邻接表类型
```

  说明：例如，AdjList V;	相当于：	VNode V[MVNum];



```c++
//弧（边）的结点结构
//adjvex	nextarc		info(权值或者其他信息)
#define MVNum 100			//最大顶点数
typedef struct ArcNode{		//边结点
	int adjvex;				//该边所指向的顶点的位置
	struct ArcNode * nextarc;	//指向下一条边的指针
	OtherInfo info;			//和边相关的信息
}ArcNode;
```



图的结构定义

```c++
typedef struct{
	AdjList vertexes;	//vertex的复数
	int vexnum,arcnum;	//图的当前顶点数和弧数
}ALGraph;
```



邻接表的操作举例说明：

```c++
ALGraph G;	//定义了邻接表表示的图G
G.vexnum = 5;G.arcnum = 5;	//图G中包含了5个顶点，5条边
G.vertexes[1].data = 'b';	//图G中第2个顶点是b
p = G.vertexes[1].firstarc;	//指针p指向顶点b的第一条边结点
p->adjvex = 4;				//p指针的邻接点所指向顶点的位置为4
```





##### 采用邻接表表示法创建无向网

算法思想：

1.输入<font color="red">总顶点数</font>和<font color="red">总边数</font>

2.建立<font color="red">顶点表</font>

​	<font color="red">依次</font>输入点的信息<font color="red">存入顶点表</font>中

​	使每个表头结点的<font color="red">指针域初始化为NULL</font>

3.创建邻接表

​	依次输入每条边依附的两个顶点

​	确定两个顶点的序号i和j，建立边结点

​	将此边结点分别插入到vi和vj对应的两个边链表的头部（头插法）

示例：采用邻接表表示法创建无向网

```c++
Status CreateUDG(ALGraph &G){	//采用邻接表表示法，创建无向图G
	cin>>G.vexnum>>G.arcnum;	//输入总顶点数，总边数
	for(i = 0; i < G.vexnum; ++i){	//输入各点，构造头结点表
		cin>>G.vertexes[i].data;	//输入顶点值
		G.vertexes[i].firstarc = NULL;	//初始化表头结点指针域
	}
	for(k = 0; k < G.arcnum; ++k){	//输入各边，构造邻接表
		cin>>v1>>v2;			//输入一条边依附的两个顶点
		i = LocateVex(G,v1);
		j = LocateVex(G,v2);
		
        p1 = new ArcNode;	//生成一个新的边结点*p1
        p1->adjvex = j;		//邻接点序号为j
        p1->nextarc = G.vertexes[i].firstarc;	//头插法将新的边													结点插入单链表
        G.vertexes[i].firstarc = p1;	//将新结点*p1插入顶点vi
        								//的边链表头部（头插法）
        //无向网，既要生成b到e的边，又要生成e到b的边
        p2 = new ArcNode;	//生成另一个对称的新的边结点*p2
        p2->adjvex = i;		//邻接点序号为i
        p2->nextarc = G.vertexes[j].firstarc;	//头插法将新的边													结点插入单链表
        G.vertexes[j].firstarc = p2;	//将新结点*p2插入顶点vj
        								//的边链表头部（头插法）
        //若是有向网的建立，上面四步可以省略
        //若逆邻接矩阵，即统计入度边，则保留上面四步删除更上面的四步
	}
    return OK;
}
```



##### 邻接表的特点

* 方便找任一顶点的所有“邻接点”

* 节约稀疏图的空间

  需要N个头结点+2E个边结点（每个结点至少两个域）有向图E个

* 方便计算任一顶点的“度”

  对无向图：是的

  对有向图：不是，只记录了出度边没有计算入度边

* 不方便计算任意两个顶点之间是否存在边





#### 邻接矩阵和邻接表表示法的关系

<font color="red">1.联系：</font>邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数

<font color="red">2.区别：</font>

* 对于任意确定的无向图，邻接矩阵是<font color="red">唯一</font>的（行列号与顶点编号一致），但邻接表<font color="red">不唯一</font>（链接次序与顶点编号无关）
* 邻接矩阵的空间复杂度为<font color="red">O(n^2^)</font>,而邻接表的空间复杂度为<font color="red">O(n+e)</font>

<font color="red">3.用途：</font>邻接矩阵多用于<font color="red">稠密图</font>；而邻接表多用于<font color="red">稀疏图</font>







#### 邻接表的改进

有向图——缺点：求结点的度困难——十字链表

无向图——缺点：每条边都要存储两遍——邻接多重表







#### 十字链表

十字链表是有向图的另一种链式存储结构。可以看成是有向图的邻接表和逆邻接表结合起来形成的一种链表

顶点结点变成三个域：data	firstin	firstout（增加一个入度边）

弧结点变成四个域：tailvex	headvex	hlink	tlink

​									hlink：弧头相同的下一条弧

​									tlink：弧尾相同的下一条弧





#### 邻接多重表

邻接表的优点：容易求得顶点和边的信息

​				缺点：某些操作不方便（如：删除一条边需找表示此边的两个结点）

 

顶点结点：

Data：存与顶点有关的信息		firstedge:指向第一条依附于该顶点的边

边结点：

mark	ivex	ilink	jvex	jlink	info

mark：标志域，标记此边是否被搜索过

ivex：该边依附的顶点在数组中的位置1

ilink：指向依附于ivex的下一条边

jvex：该边依附的顶点在数组中的位置2

jlink：指向依附于jvex的下一条边

info：存放与边结点有关的信息







### 图的遍历

定义：从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使<font color="red">每个顶点仅被访问一次</font>，就叫做图的遍历，它是图的基本运算

实质：找到每个顶点的邻接点的过程

图的特点：图中可能存在<font color="red">回路</font>，且图的任一顶点都可能与其它顶点相同，在访问完某个顶点之后可能会沿着某些变又回到了曾经访问过的顶点



怎么避免重复访问？

<font color="red">思路：</font>设置辅助数组visited[n]，用来标记每个被访问过的顶点

* 初始状态：<font color="red">visited[i]为0</font>
* <font color="red">顶点i被访问，该visited[i]为1，</font>防止被多次访问



图常用的遍历：

* 深度优先搜索（DFS）
* 广度优先搜索（BFS）



#### **深度优先遍历**

方法：

1.在访问图中某一起始顶点<font color="red">v</font>后，由v出发，访问<font color="red">它的任一邻接顶点w1</font>

2.再从w1出发，访问<font color="red">与w1邻接</font>但还<font color="red">未被访问过</font>的顶点w2；

3.然后再从w2出发，进行类似的访问…

4.如此进行下去，直至到达所有的邻接顶点都被访问过的顶点u为止

5.接着，退回一步，退到前一次刚访问过的顶点，看是否还有其他没有被访问的邻接结点

6.如果有，则访问此结点，之后再从此顶点出发，进行与前述类似的访问

7.如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止

连通图的深度优先遍历类似于树的先根遍历



#### 非连通图的深度优先遍历

分别对不同的连通分量进行深度优先遍历

通过访问完栈空的次数可以判断当前非连通图连通分量的数目





#### 深度优先搜索遍历算法的实现

邻接矩阵表示的无向图深度遍历实现：

邻接矩阵

| 顶点 |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  0   |  1   |  1   |  1   |  0   |  0   |
|  2   |  1   |  0   |  0   |  0   |  1   |  0   |
|  3   |  1   |  0   |  0   |  0   |  1   |  0   |
|  4   |  1   |  0   |  0   |  0   |  0   |  1   |
|  5   |  0   |  1   |  1   |  0   |  0   |  0   |
|  6   |  0   |  0   |  0   |  1   |  0   |  0   |



 辅助数组visited[n]

|            | 1    | 2    | 3    | 4    | 5    | 6    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- |
| visited[i] | 0    | 0    | 0    | 0    | 0    | 0    |

 

深度优先算法，定了数据存储结构后就定了遍历顺序



采用<font color="red">邻接矩阵</font>表示图的深度优先搜索遍历

```c++
void DFS(AMGraph G,int v){		//图G为邻接矩阵类型
	cout<<v; visited[v] = true;	//访问第v个顶点
    for(w = 0; w < G.vexnum; w++)	//依次检查邻接矩阵v所在的行
        if((G.arc[v][w] != 0)&&(!visited[w]))
            DFS(G,w);
    //w是v的邻接点，如果w未访问，则递归调用DFS
}
```



#### 深度优先算法效率分析

* 用邻接矩阵来表示图，遍历图中每一个顶点都要<font color="red">从头扫描</font>该顶点所在行，时间复杂度为<font color="red">O(n^2^)</font>
* 用邻接表来表示图，虽然有<font color="red">2e</font>个表结点，但只需扫描<font color="red">e</font>个结点即可完成遍历，加上访问<font color="red">n</font>个头结点的时间，时间复杂度为<font color="red">O(n+e)</font>

**结论：**

* <font color="red">稠密图</font>适于在邻接矩阵上进行深度遍历；
* <font color="red">稀疏图</font>适于在邻接表上进行深度遍历









#### 广度优先遍历

方法：从图的某一结点出发，首先依次访问该结点的所有邻接结点vi1,vi2,…,vin再按这些顶点被访问的先后次序依次访问与它们项邻接的所有未被访问的顶点。重复此过程，直到所有顶点均被访问为止



#### 非连通图的广度优先遍历

分别对每一个连通分量进行广度优先遍历



#### 广度优先遍历的实现

利用队列实现，入队的元素是结点在数组中的位置下标



按广度优先非递归遍历遍历连通图G

```c++
void BFS(Graph G, int v){	//按广度优先非递归遍历连通图G
    cout<<v; visited[v] = true;	//访问第v个顶点
    InitQueue(Q);			//辅助队列Q初始化，置空
    EnQueue(Q,v);			//v进队
    while(!QueueEmpty(Q)){	//队列非空
        DeQueue(Q,u);		//队头元素出队并置为u
        for(w = FirstAdjvex(G,u);w >= 0;w = NextAdjVex(G,u,w))
        	if(!visited[w]){	//w为u的尚未访问的邻接顶点
                cout<<w; visited[w] = true;
                EnQueue(Q,w);	//w进队
            }
    }
}
```





#### 广度优先算法效率分析

* 如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（n个元素），总的时间复杂度为<font color="red">O(n^2^)</font>
* 如果使用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<font color="red">O(n+e)</font>



#### DFS和BFS算法效率比较

* 空间复杂度相同，都是<font color="red">O(n)</font>（借用了堆栈或者队列）
* 时间复杂度相同，都是<font color="red">O(n+e)</font>，只与存储结构<font color="red">（邻接矩阵或邻接表）</font>有关，而与搜索路径无关





### 图的应用

#### 最小生成树

生成树：所有顶点均由边连接在一起，但<font color="red">不存在回路</font>的图

<font color="red">一个图可以有许多棵不同的生成树</font>

<font color="red">所有生成树具有以下共同特点：</font>

* 生成树的顶点个数与图的<font color="red">顶点个数相同</font>
* 生成树是图的<font color="red">极小连通子图</font>，去掉一条边则非连通
* 一个有n个顶点的连通图的生成树有<font color="red">n-1</font>条边
* <font color="red">在生成树中再加一条边必然形成回路</font>
* 生成树中任意两个顶点间的<font color="red">路径是唯一的</font>

含n个顶点n-1条边的图不一是生成树



##### 无向图的生成树

先将图遍历一遍，然后在结点中间加一条边就变成了生成树

利用深度优先算法得到的生成树叫深度优先生成树，同理还有广度优先生成树



设图G = （V，E）是个连通图，当从图任一顶点出发遍历图G时，将边集E（G）分成两个集合T（G）和B（G)。其中T(G)是遍历图时所经过的边的集合，B(G)是遍历图时未经过的边的结合。显然，G1（V,T)是图G的极小连通子图。即子图G1是连通图G的<font color="red">生成树</font>



**最小生成树**：给定一个无向网络，在该网的所有生成树中，使得<font color="red">各边权值之和最小</font>的那棵生成树称为该网的<font color="red">最小生成树</font>，也叫**最小代价生成树**





##### 最小生成树的典型用途

* 欲在n个城市间建立通信网，则n个城市应铺n-1条线路；
* 但因为每条线路都会有对应的经济成本，而n个城市最多有n(n-1)/2条线路，那么，如何选择n-1条线路，使总费用最少？

数学模型：

顶点：表示城市，有n个

边：表示线路，有n-1条

边的权值：表示线路的经济代价

连通网：表示n个城市间通信网



##### 构造最小生成树

构造最小生成树的算法很多，其中多数算法都利用了<font color="red">MST</font>（即Minimum Spanning Tree——最小生成树）的性质

MST性质：设N=（V，E）是一个连通网，U是顶点集V的一个非空子集。若边（u，v）是一条具有最小权值的边，其中u∈U，v属于V-U，则必存在一棵包含边（u，v）的最小生成树



MST性质解释：

在生成树的构造过程中，图中n个顶点分属两个集合：

* 已落在生成树上的顶点集：<font color="red">U</font>
* 尚未落在生成树上的顶点集：<font color="red">V-U</font>

接下来则应在所有连通U中顶点和V-U中顶点选取**权值最小的边**加入生成树（不能有回路，如果出现回路的话，重新选择下一条权值最小的边）





**方法一：普利姆（Prim）算法**

算法思想：

1.设N=（V,E)是连通网，TE是N上最小生成树中边的集合（TE中应有n-1条边）

2.初始令U={u~0~}，（u~0~∈V），TE={}

3.在所有u∈U，v∈V-U的边（u，v）∈E中，找一条代价最小的边（u~0~，v~0~）

4.将（u~0~，v~0~）并入集合TE，同时v~0~并入U

5.重复上述操作直到U=V为止，则T（V,TE）为N的最小生成树



**方法二：卡鲁斯卡尔（Kruskal）算法**

算法思想：

1.设连通网N=（V，E），令最小生成树初始状态为<font color="red">只有</font>n个<font color="red">顶点</font>而<font color="red">无边</font>的非连通图T=（V，{}），每个顶点自成一个连通分量

2.在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上（即：<font color="red">不能形成环</font>），则将此边加入到T中；否则，舍去此边，选取下一条代价最小的边

3.以此类推，直到T中所有顶点都在同一连通分量上为止

<font color="red">最小生成树可能不唯一</font>



**两种算法比较**

| 算法名     | 普利姆算法 | 克鲁斯卡尔算法                  |
| ---------- | ---------- | ------------------------------- |
| 算法思想   | 选择点     | 选择边                          |
| 时间复杂度 | O(n^2^)    | O(eloge)   排序算法的时间复杂度 |
| 适应范围   | 稠密图     | 稀疏图  边少的时候更快          |







#### 最短路径

典型用途：交通网络的问题——从甲地到乙地是否有公路连通？在有多条通路的情况下，哪一条路最短？



交通网络用<font color="red">有向网</font>来表示

顶点：表示地点

弧：表示两个地点有路连通

弧上的权值：表示两地点之间的距离、交通费或途中所花费的时间等



问题抽象：在有向网中，<font color="red">源点</font>到达<font color="red">终点</font>的多条路径中，寻找一条<font color="red">各边权值最小</font>的路径，即<font color="red">最短路径</font>



<font color="red">最短路径与最小生成树不同，路径上不一定包含n个顶点，也不一定包含n-1个边</font>



**两种常见的最短路径问题：**

**第一类问题：两点间最短路径**

求某一个顶点到其他顶点的最短路径，用Dijkstra（迪杰斯特拉）算法

**第二类问题：某源点到其他各点最短路径**

求所有顶点间的最短路径，用Floyd（弗洛伊德）算法





##### Dijkstra算法

算法思路：

1.<font color="red">初始化</font>：先找出源点v~0~到各终点v~k~的直达路径（v~0~，v~k~）,即通过一条弧到达的路径，若不能通过一条弧就到达，则把这条弧的权值记为无穷大

2.<font color="red">选择</font>：从这些路径中找出一条长度最短的路径（v~0~，u）

3.<font color="red">更新</font>：然后对其余各条路径进行适当调整：<font color="red">若在图中存在弧（u，v~k~）且（u，v~k~）+（v~0~，u）<（v~0~，v~k~），则以路径（v~0~,u,v~k~）代替（v~0~，v~k~）</font>

4.在调整后的各条路径中，再找长度最短的路径，以此类推



**按路径长度递增顺序产生最短路径**

1.把v分成两组：

* S：已求出的最短路径的顶点的集合
* T = V - S：尚未确定的最短路径的顶点集合

2.将T中顶点按最短路径递增的顺序加入到S中

保证：

* 从源点v~0~到S中各顶点的最短路径长度都不大于从v~0~到T中任何顶点的最短路径长度
* 每个顶点对应一个<font color="red">距离值</font>
  * S中顶点：从v~0~到此顶点的最短路径长度
  * T中顶点：从v~0~到此顶点的只包括S中顶点作中间顶点的最短路径长度



**算法步骤：**

1.初始时令S={v~0~}，T={其余顶点}。T中顶点对应的距离值用辅助数组D存放

​	**D[i]初值：**若<v~0~,v~i~>存在，则为其权值，否则为∞

2.从T中选取一个其距离值最小的顶点v~j~，加入S

3.对T中顶点的距离值进行修改：若加进v~j~作中间顶点，从v~0~到v~i~的距离值比不加v~j~的要短，则修改此距离值

4.重复上述步骤，直到S=V为止





##### Floyd算法

**求所有顶点间的最短路径：**

方法一：每次以一个顶点为源点，重复执行Dijkstra算法n次，时间复杂度O(n^3^)

方法二：弗洛伊德算法，时间复杂度O(n^3^)



算法思想：

* 逐个顶点<font color="red">试探</font>
* 从v~i~到v~j~的所有可能<font color="red">存在的</font>路径中
* 选出一条长度<font color="red">最短的</font>路径



求最短路径步骤：

1.初始时设置一个n阶方阵，令其对角线元素为0，若存在弧<v~i~,v~j~>,则对应元素为权值；否则为∞

2.逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之；否则，维持原值。所有顶点试探完毕，算法结束。





#### 拓扑排序

**有向无环图**：无环的有向图，简称DAG图（Directed Acycline Graph）

有向无环图常用来描述一个工程或系统的进行过程。（通常把计划、施工、生产、程序流程等当成是一个工程）

一个工程可以分为若干个子工程，只要完成了这些子工程（活动），就可以导致整个工程的完成

 

**AOV网：**

用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以<font color="red">顶点表示活动，弧表示活动之间的优先制约关系</font>，称这种有向图为<font color="red">顶点表示活动的网吗，</font>简称<font color="red">AOV网</font>（Activity On Vertex network）



**AOE网：**

<font color="red">解决关键路径问题</font>

用一个有向图表示一个工程的各子工程及其相互制约关系，以<font color="red">弧表示活动</font>，以<font color="red">顶点表示活动的开始或结束事件</font>，称这种有向图为<font color="red">边表示活动的网</font>，简称为<font color="red">AOE网</font>（Activity On Edge）





AOV网的特点：

* 若从i到j有一条有向路径，则i是j的前驱，j是i的后继
* 若<i,j>是网中的有向边，则i是j的直接前驱；j是i的直接后继
* AOV网中不允许有回路，因为如果有回路存在的话，则表明某活动以自己为先决条件，显然这是荒谬的



如何判别AOV网中是否存在回路？



拓扑排序

在AOV网没有回路的情况下，我们将全部活动排成一个线性序列，使得若AOV网中有弧<i,j>存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为<font color="red">拓扑有序序列</font>，相应的拓扑有序排列的算法称为<font color="red">拓扑排序</font>



拓扑排序的方法：

1.在有向图中选一个没有前驱的顶点且输出之

2.从图中删除该顶点和所有以它为尾的弧

3.重复上述两步，直到所有顶点均已输出；或者当图中不存在无前驱的顶点为止

<font color="red">一个AOV网的拓扑序列不是唯一的</font>



拓扑排序的一个重要应用：

检测AOV网中<font color="red">是否存在环</font>方法：

​	对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV	网必定不存在环





#### 关键路径

把工程计划表示为<font color="red">边表示活动的网络</font>，即<font color="red">AOE网</font>，用顶点表示<font color="red">事件</font>，弧表示<font color="red">活动</font>，弧的权表示活动持续时间

<font color="red">事件</font>表示在它之前的活动已经完成，在它之后的活动可以开始



设：一个工程有11项活动，9个事件

事件v1——表示整个工程开始（<font color="red">源点：入度为0的顶点</font>）

事件v9——表示整个工程结束（<font color="red">汇点：出度为0的顶点</font>）



对于AOE网，我们关心两个问题：

1.完成整项工程至少需要多少时间？

2.<font color="red">哪些活动是影响工程进度的关键？</font>

—><font color="red">求解关键路径的问题</font>

<font color="red">关键路径：</font>路径长度最长的路径

路径长度：路径上各活动持续时间之和



如何确定关键路径，需要定义4个描述量：

<font color="red">ve(vj)</font>:表示事件vj的最早发生时间

<font color="red">vl(vj)</font>:表示事件vj的最迟发生时间

<font color="red">e(i)</font>:表示活动ai的最早开始时间

<font color="red">l(i)</font>:表示活动ai的最迟开始时间

l(i) - e(i):表示完成活动ai的时间余量

<font color="red">关键活动：</font>关键路径上的活动，即l(i) ==e(i) ( 即 l(i) - e(i) == 0 )的活动



**如何找l(i) == e(i) 的关键活动？**

设活动ai用弧<j,k>表示，其持续时间为：w~j,k~

则有：1.e(i) = <font color="red">ve(j)</font>

​			2.l(i) = <font color="red">vl(k)</font> - w~j,k~

**如何求ve(j)和vl(k)?**

1.从ve(1) = 0 开始向前递推

​	ve(j) = Max{ve(i) + w~i,j~ }, <i,j>∈T, 2<=j<=n

​	其中T是所有以j为头的弧的集合

2.从vl(n) = ve(n) 开始向后递推

​	vl(i) = Min{vl(j) - w~i,j~},  <i,j> ∈ S, 1<=i<=n-1

​	其中S是所有以i为尾的弧的集合

 

**求关键路径步骤：**

1.求ve(i)、vl(j)

2.求e(i)、l(i)

3.计算l(i) - e(i)



**关键路径的讨论**

1.若网中有几条关键路径，则需加快同时在几条关键路径上的关键活动

2.如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间

3.处于所有关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径





## 查找


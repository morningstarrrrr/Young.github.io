---
title: 数据结构
date: 2021-08-04 17:54:42
tags: 数据结构
categories: 学习
cover: https://morningstarrrrr-blog-pic-1306711961.cos.ap-chengdu.myqcloud.com/DataStructure.png
description: 青岛大学-王卓《数据结构与算法基础》学习记录
---

<center>数据结构</center>

---

## <center>绪论</center>

### 🎈数据结构的研究内容

**计算机解决问题的步骤：**

* 将问题抽象为<font color="red">数学模型</font>
* 设计算法
* 编程、调试、运行



**早期，计算机应用于数值计算：**

* 分析问题，找出对象以及对象之间的关系
* 建立数学方程
* 求解



**随着计算机应用领域的扩展，越来越多被用于非数值计算：**

* 线性表
* 树
* 图

以上都是“非数值计算”的程序设计问题



> 综上所述，数据结构是一门研究<font color="red">非数值计算的</font>程序设计中计算机的<font color="red">操作对象</font>以及他们之间的<font color="red">关系</font>和<font color="red">操作</font>的学科。

### 🎈基本概念和术语

#### 数据、数据元素、数据项和数据对象

1. 数据(Data)：是描述客观事物的符号，是计算机中可以操作的对象，是能被输入计算机且能被计算机处理的各种符号的集合。

   包括：

* 数值型数据：整数、实数等
* 非数值型数据：文字、图像、图形、声音等

2. 数据元素(Data element)：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，也称为元素、记录、结点或顶点。
3. 数据项：构成数据元素的不可分割的最小单位

> <font color="red">以上三者之间的关系：</font>数据>数据元素>数据项

4. 数据对象(Data Object)：性质相同的数据元素的结合，是数据的一个子集。

   数据元素和数据对象与数据的关系的区别：

* 数据元素是集合的个体
* 数据对象是集合的子集

#### 数据结构

* 数据元素互相之间的关系称为<font color="red">结构</font>

* 是指相互之间存在一种或多种特定关系的数据元素集合

* <font color="red">包含以下三方面内容：</font>

  1. 数据元素之间的逻辑关系，也称为<font color="red">逻辑结构</font>
  2. 数据元素及其关系在计算机内存中的表示（又称为映像）称为数据的<font color="red">物理结构</font>或数据的<font color="red">存储结构</font>
  3. 数据的<font color="red">运算和实现，</font>即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现

* 数据结构的两个层次：

  1. <font color="red">逻辑结构：</font>是指数据对象中数据元素之间的互相关系

     **逻辑结构的种类：**

     划分方法一：

     1. <font color="red">线性结构：</font>有且仅有一个开始和终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。
     2. <font color="red">非线性结构：</font>一个结点可能有多个直接前驱和直接后继。

     划分方法二：

     1. <font color="red">集合结构：</font>其中的数据元素只有<font color="red">只属于一个集合</font>的关系
     2. <font color="red">线性结构：</font>数据元素存在<font color="red">一对一</font>的线性关系
     3. <font color="red">树形结构：</font>数据元素存在<font color="red">一对多</font>的线性关系
     4. <font color="red">图状/网状结构：</font>数据元素存在<font color="red">多对多</font>的线性关系

  2. <font color="red">物理结构（存储结构）：</font>是指数据的逻辑结构在计算机中的存储形式

     **存储结构的种类：**

     ​	<font color="red">四种基本的存储结构：</font>

     ​	1.<font color="red">顺序存储结构：</font>用一组连续的存储单元一次存储数据元素，数据元素之间的逻辑关系用存储位置表示

     ​	2.<font color="red">链式存储结构：</font>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示

     ​	3.<font color="red">索引存储结构：</font>在存储结点信息的同时，还建立附加的索引表（其中的每一项称为索引项）

     ​	4.<font color="red">散列存储结构：</font>根据结点的关键字直接计算出该结点的存储地址

     **逻辑结构和存储结构之间的关系：**

     * 存储结构是逻辑关系的映像与元素本身的映像
     * 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
     * 两者综合起来建立了数据元素之间的结构关系


#### 数据类型

数据类型(Data Type):是指一组性质相同的<font color="red">值的集合</font>及定义在此集合上的<font color="red">一组操作</font>的总称

> 数据类型 = 值的集合 + 值集合上的一组操作

**在C语言中，按照取值的不同，可以分为两类：**

* 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等
* 结构类型：有若干个类型集合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的

#### 抽象数据类型

{% label 抽象是指抽取出事物具有的普遍性的本质。 red %}

通过对已有的数据类型进行抽象得到。

抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。

* 由用户定义，从问题中抽象出<font color="red">数据模型</font>（逻辑结构）。
* 还包括定义在数据模型上的一组<font color="red">抽象运算</font>（相关操作）。

**抽象数据类型的形式定义：**

抽象数据类型可以用（D，S，P）<font color="red">三元组</font>表示。

其中：D是数据对象；

​			S是D上的关系集；

​			P是对D的基本操作集。

**抽象数据类型的定义格式如下：**

```c++
ADT 抽象数据类型名
{
	数据对象：<数据对象的定义>		//其中，数据对象和数据关系用伪代码描述
	数据关系：<数据关系的定义>		//基本操作的定义格式为：
	基本操作：<基本操作的定义>		// 基本操作名（参数表）
}ADT 抽象数据类型名			   // 初始条件：<初始条件描述>
    							// 操作结果：<操作结果描述>                     
```

------

**基本操作**定义格式说明：

参数表：赋值参数 只为操作提供输入值

​				引用参数 以&打头，除可提供输入值外，还将返回操作结果

初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。

操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果。

```
ADT 抽象数据类型名{
Data
	数据对象的定义
	数据元素之间逻辑关系的定义
Operation
	操作1
		初始条件
		操作结果描述
	操作2
		...
	操作n
		...
		
}ADT 抽象数据类型名
```



## <center>算法</center>

**数据额结构和算法的关系是相互依赖不可分割的。**

### 🎈算法定义

算法是解决特定问题**求解方法和步骤**的描述，在计算机中表现为<font color="red">指令</font>的有限<font color="red">序列</font>，并且每条指令表示一个或多个操作。

**算法的描述：**

* 自然语言：中文、英语
* 流程图
* 伪代码
* 程序代码

**算法与程序：**

**算法**是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法

**程序**是用某种程序设计语言对算法的具体实现

> 程序 = 数据结构 + 算法

### 🎈算法的特性

#### 输入输出

* 算法具有零个或多个输入
* 算法至少有一个或多个输出

#### 有穷性

算法在执行有穷步之后结束，并且每一个步骤在有穷的时间内完成。

#### 确定性

算法的每一步骤都具有确定的含义，不会出现二义性，任何条件下只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。

#### 可行性

算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。

### 🎈算法设计的要求

#### 正确性

算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

可以分为四个层次：

1. 算法程序<font color="red">不含语法错误</font>
2. 算法程序对于<font color="red">几组输入数据</font>能够产生满足要求的输出结果。
3. 算法程序对于<font color="red">精心选择的、典型、苛刻且带有刁难性的</font>几组输入数据能够得出满足要求的结果。
4. 算法程序对于<font color="red">一切合法的输入数据</font>都有满足要求的输出结果。

一般情况下，把<font color="red">第三层</font>作为衡量一个算法是否合格的标准。同时，一个好的算法还要容易理解。

#### 可读性

算法设计的另一目的是为了便于阅读、理解和交流。隐晦难读的算法易于隐藏较多错误难以调试

#### 健壮性

* 当<font color="red">输入非法数据</font>时，算法也能恰当做出反应和处理，而不是产生异常或莫名奇妙的结果。
* 处理出错的方法，不应该是中断程序的执行，而应返回一个表示错误或错误属性的值，以便在更高的抽象层次上进行处理。

#### 时间效率高和存储量低

设计算法应该尽量满足时间效率高和存储量低的需求。

### 🎈算法效率的度量方法

**算法效率从以下两个方面来考虑：**

<font color="red">1.时间效率： </font>指的是算法所耗费的时间

<font color="red">2.空间效率：</font>指的是算法执行过程中所耗费的存储空间

**时间效率和空间效率有时候是矛盾的**

#### 事后统计方法

将算法实现，测试其时间和空间开销。缺陷：编写程序耗费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣。

#### 事前分析估算方法

**<font color="red">算法运行时间指算法中每条语句的频度之和（假设每条语句时间为单位时间）</font>**

在计算机程序编制前，依据统计方法对算法进行估算。

程序在计算机上运行时所消耗的时间取决于下列因素：

1. 算法采用的策略、方法
2. 编译产生的代码质量
3. 问题的输入规模
4. 机器指令执行的速度

> 抛开软件和硬件的因素，一个程序的运行时间，依赖于**算法的好坏和问题的输入规模**。问题输入规模是指输入量的多少。

**在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。**

### 🎈函数的渐近增长

> 定义：给定两个函数f（n）和g（n），如果存在一个整数N，是的对于所有n>N，f（n）总是比g（n）大，那么，我们说f（n）的增长渐近快于g（n）。

结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。

### 🎈算法时间复杂度

#### 算法时间复杂度定义

> 在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并确定T（n）的数量级。算法的时间复杂度，也就是算法的时间量度，记作 T(n)=O(f(n)) 。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作<font color="red">**渐进时间复杂度**</font>，简称为时间复杂度。一般情况下，不必计算所有操作的 执行次数，而只考虑算法中**基本操作**执行的次数，它是问题规模n的某个函数，用T（n）表示。

这样用大写 O() 来体现算法时间复杂度的记法，称之为大O记法。

一般情况下，随着n的增大，T（n）增长最慢的算法为最优算法。

**分析算法时间复杂度的基本方法：**

1. 找出<font color="red">语句频度最大</font>的那条语句作为<font color="red">基本语句</font>
2. 计算<font color="red">基本语句</font>的频度得到问题规模n的某个函数f（n）
3. 取其数量级用符号“O”表示

#### 推导大O阶方法

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数
4. 得到的结果就是大O阶

#### 常数阶

如果一个算法，无论n为多少，上面的两端代码执行的次数是不变的。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O（1）的时间复杂度，又叫常数阶。

{% label 即执行次数恒定，不会随着n的变大而发生变化 red %}

#### 线性阶

要确定某个算法的阶次，我们常常要确定某个特定语句或者某个语句集运行的次数。因此，我们要**分析算法的复杂度，关键就是要分析循环结构的运行情况**。

下面这段代码，它的循环的时间复杂度为O（n），因为循环体中的代码需要执行n次。

```c++
int i;
for(i = 0; i < n; i++)
{
	/* 时间复杂度为O（1）的程序步骤序列 */
}
```

#### 对数阶

```c++
int count = 1;
while(count < n)
{
	count = count * 2;
	/* 时间复杂度为O（1）的程序步骤序列 */
}
```

有多少个2相乘后大于n，就会退出循环。由 2<sup>x</sup>=n 得到 x=log<sub>2</sub>n 。所以这个循环的时间复杂度为 O(log<sub>n</sub>) 。

#### 平方阶

```c++
int i,j;
for (i = 0; i < n; i++)
{
	for (j = 0; j < n; J++)
	{
		/* 时间复杂度为O（1）的程序步骤序列 */
	}
}
```

它的内循环的时间复杂度为O（n），而它的外循环是对于内部时间复杂度为O（n）的语句，再循环n次。所以它的时间复杂度为O（n<sup>2</sup>）。

如果外循环的循环次数改成了m，那么时间复杂度就变为O（m*n）。

总结得出，<font color="red">循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</font>。

对于下面这个循环嵌套：

```c++
int i,j;
for(i = 0; i < n; i++)
{
	for (j = i; j < n; j++) /* 注意int j = i 而不是0 */
	{
		/* 时间复杂度为O（1）的程序步骤序列 */
	}
}
```

当i=0时，内循环执行了n次，当i=1时，内循环执行了n-1次，……当i=n-1时，执行了1次。所以总执行次数为：

<center>n+(n-1)+(n-2)+···+1=n(n+1)/2+n/2</center>

用推导大O阶的方法，得出这段代码的时间复杂度为O（n<sup>2</sup>）。



#### 算法的加法法则和乘法法则

* 加法法则

  T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O( max ( f(n) , g(n) ) )

* 乘法法则

  T(n) = T1(n) * T2(n) = O(f(n)) + O(g(n)) = O( f(n) * g(n) )

#### 🎈常用的时间复杂度

|            执行次数函数            |           阶           |     非正式术语      |
| :--------------------------------: | :--------------------: | :-----------------: |
|                 12                 |         O（1）         |       常数阶        |
|                2n+3                |         O（n）         |       线性阶        |
|        3n<sup>2</sup>+2n+1         |   O（n<sup>2</sup>）   |       平方阶        |
|        5log<sub>2</sub>n+20        | O（log<sub>2</sub>n）  |       对数阶        |
|      2n+3nlog<sub>2</sub>n+19      | O（nlog<sub>2</sub>n） | nlog<sub>2</sub>n阶 |
| 6n<sup>3</sup>+2n<sup>2</sup>+3n+4 |   O（n<sup>3</sup>）   |       立方阶        |
|           2<sup>n</sup>            |   O（2<sup>n</sup>）   |       指数阶        |

常用的时间复杂度所耗费的时间从小到大依次是：

> O（1）<O（log<sub>2</sub>n）< O（n）<O（nlog<sub>2</sub>n）<O（n<sup>2</sup>）<O（n<sup>3</sup>）<O（2<sup>n</sup>）<O（n！）<O（n<sup>n</sup>）

### 🎈最坏情况与平均情况

* **最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。**
* 平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。（一般通过运行一定数量的实验数据后估算出来的）

### 🎈算法空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作： S(n) = O(f(n)) ，其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数。

**算法要占据的空间：**

* 算法本身要占据的空间，输入/输出，指令，常数，变量等
* 算法要使用<font color="red">辅助空间</font>

------

## <center>🍟线性表</center>

### 🎵线性表的定义和特点

**线性表(Linear List):**

* 由n个数据元素（结点）组成的<font color="red">有限序列</font>
* 其中数据元素的个数n定义为表的长度
* 当n=0时称为空表
* 数据元素ai只是一个抽象的符号，其具体含义在不同的情况下可以不同

<font color="red">同一线性表中的元素必定具有相同特征，数据元素间的关系是线性关系</font>

#### **线性表的逻辑特征**

1. 非空的线性表有且只有一个开始结点，它没有直接前驱，而且仅有一个直接后继
2. 有且只有一个终端结点，它没有直接后继，而仅有一个直接前驱
3. 其余的内部结点有且只有一个直接前驱和一个直接后继

<font color="red">线性表是一种典型的线性结构</font>

**总结：**

* 线性表中的数据元素的类型可以为**简单类型**，也可以为**复杂类型**
* 许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序
* 从具体应用中抽象处共性的**逻辑结构和基本操作**（抽象数据类型），然后实现其**存储结构和基本操作**



#### **顺序表的类型定义**

* 抽象数据类型线性表的定义如下：

```c++
ADT List{
	数据对象：D = {ai|ai∈Elemset,(i=1,2,...,n,n>=0)}
	数据关系：R = {<ai-1,ai>|ai-1,ai∈D,(i=2,3,...n)}    //这里的ai中的i都是下标
	基本操作：
	InitList(&L);
	ListInsert(&L,i,e);
	DestroyList(&L);
	ListDelete(&L,i,&e);
	......等等
}ADT List
```



### 🎵基本操作

* InitList(&L)   (Initiallization List)

  * 操作结果：构造一个空的线性表L

* DestroyList(&L)

  * 初始条件：线性表L已经存在

  * 操作结果：销毁线性表L

* ClearList(&L)

  * 初始条件：线性表L已经存在

  * 操作结果：将线性表L重置为空表

* ListEmpty(L);

  * 初始条件：线性表L已经存在

  * 操作结果：若线性表L为空表，则返回TRUE；否则返回FALSE

* ListLength(L

  * 初始条件：线性表L已经存在

  * 操作结果：返回线性表L中的数据元素的个数

* GetElem(L,i,&e)

  * 初始条件：线性表L已经存在，1 <= i <= ListLength(L)
  * 操作结果：用e返回线性表L中第i个数据元素的值

* LocateElem(L,e,compare())

  * 初始条件：线性表L已经存在，compare()是数据元素判定函数
  * 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0

* PriorElem(L,cur_e,&pre_e)

  * 初始条件：线性表L已经存在
  * 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义

* NextElem(L,cur_e,&next_e)

  * 初始条件：线性表L已经存在
  * 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无意义

* ListInsert(&L,i,e)

  * 初始条件：线性表L已经存在， 1 <= i<= ListLength(L) + 1
  * 操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加1

* ListDelete(&L,i,&e)

  * 初始条件：线性表L已经存在， 1 <= i<= ListLength(L) 
  * 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一

* ListTraverse(&L,visited())

  * 初始条件：线性表L已经存在
  * 操作结果：依次对线性表中每个元素调用visited()



**以上的运算都是逻辑结构上定义的运算，只有在确定了存储结构之后才考虑具体的实现细节。**





### 🎵线性表的顺序存储表示

顺序表的顺序表示又称为<font color="red">顺序存储结构</font>或<font color="red">顺序映像</font>

#### <font color="red">**顺序存储定义**</font>

把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的顺序结构

* 依次存储，地址连续——中间<font color="red">没有空出存储单元</font>

* 线性表顺序存储结构<font color="red">占用一片连续的存储空间。</font>知道某个元素的存储位置就可以计算其他元素的存储位置



#### **顺序表中元素存储位置的计算**

* 假设线性表中每个匀速需要占K个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：<font color="red">LOC(a~i+1~) = LOC(a~i~) + K</font>

* 所有数据元素的存储位置均可由第一个数据元素的存储位置得到：<font color="red">LOC(a~i~) = LOC(a~1~) + (i-1) * K </font>。其中<font color="red">LOC(a~1~) </font>称为<font color="red">基地址</font>。



#### **顺序表的特点**

<font color="red">以物理位置相邻表示逻辑关系。任意元素均可随机存取</font>（优点）

顺序表与数组特点相同：地址连续、依次存放、随机存取、类型相同即<font color="red">用一维数组表示顺序表</font>

但线性表长度可变（删除），数组长度不可动态定义

一维数组定义方式：``类型说明符 数组名[常量表达式]``

说明：常量表达式中可以包含常量和符号常量，不能包含变量。即C语言中不允许对数组的大小作动态定义。<font color="red">即需要重新用一个变量表示线性表的长度，且在程序开头就定义一个常量作为线性表可能达到的最大长度</font>。



#### **定义顺序表类型**

```
#define MAXSIZE 100
typedef struct{
	ElemType *elem;
	int length;
}SqList;  //定义数据表类型

SqList L; //定义变量L
```



### **🎵顺序表基本操作的实现**

#### 操作算法中用到的预定义常量和类型

```c++
//函数结果状态代码
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0
#define INFEASIBLE -1
#define OVERFLOW -2
//Status 是函数类型
typedef int Status;
```

#### 线性表L的初始化

```c++
Status InitList_Sq(SqList &L){
	L.elem = new ElemType[MAXSIZE];
	if(!L.elem)exit(OVERFLOW);
	L.length=0;
	return OK;
}
```

#### 销毁线性表

```c++
void DestoryList(SqList &L){
	if(L.elem) delete L.elem;
}
```

#### 清空线性表

```c++
void ClearList(SqList &L){
	L.length = 0;
}
```

#### 求线性表长度

```c++
int GetLength(SqList L){
	return(L.length);
}
```

#### 判断线性表L是否为空

```c++
int IsEmpty(SqList L){
	if(L.length == 0) return 1;
	else return 0;
}
```

#### 顺序表取值

```c++
int GetElem(SqList L,int i,ElemType &e){
	if(i<1||i>L.length) return ERROR;  //判断i的值是否合理
	e = L.elem[i-1];
	return OK;
}
```

#### 顺序表的查找

```c++
int LocateElem(SqList L,ElemType e){     //查找值为e的元素，返回其序号
	for(i=0;i<L.length;i++){
		if(L.elem[i] == e) return i+1;
	}
	return 0;
}
```

**顺序表的查找算法分析**

平均算法长度ASL(Average Search Length):为确定记录在表中的位置，需要与给定值进行比较的关键字的个数期望值叫做查找算法的平均查找长度。

* 用第i个记录被查找的概率乘以找到第i个记录需要比较的次数相加

(1/n)*[(n+1)(n) / 2]

顺序表查找的时间复杂度为O（n）



#### 顺序表的删除

```c++
Status ListDelete_Sq(SqList &L,int i){
	if((i<1)||(i>L.length)) return ERROR;
	for(j=i;j<=L.length;j++){
		L.elem[j-1]=L.elem[j];
	}
	L.length--;
	return OK;
}
```

#### **顺序表的删除算法分析**

(1/n)*[(n-1)n / 2]

顺序表删除的时间复杂度O（n）



### 🎵线性表的链式存储表示

* 用一组<font color="red">物理位置任意的存储单元</font>来存放线性表的数据元素
* 这组存储单元既可以是<font color="red">连续</font>的，也可以是<font color="red">不连续</font>的，甚至是零散分布在内存中的任意位置上的
* 链表中元素的<font color="red">逻辑次序和物理次序不一定相同</font>



#### **与链式存储有关的术语**

1. <font color="red">结点：</font>数据元素的存储映像。由数据域和指针域两部分组成
2. <font color="red">链表：</font>n个结点由<font color="red">指针链</font>组成一个链表
3. <font color="red">单链表、双链表、循环链表：</font>
   * 结点只有一个指针域的链表，称为单链表或线性链表
   * 结点有两个指针域的链表，称为双链表
   * 首尾相接的链表称为循环链表
4. <font color="red">头指针、头结点、首元结点</font>



#### <font color="red">**讨论**</font>

**如何表示空表？**

* 无头结点时，<font color="red">头指针为空</font>表示空表
* 有头结点时，<font color="red">当头结点的指针域为空时</font>表示空表

**在链表中设置<font color="red">头结点</font>有什么好处？**

* 便于<font color="red">首元结点</font>的处理
* 便于<font color="red">空表与非空表</font>的统一处理

**头结点的<font color="red">数据域</font>中装的是什么？**

头结点的<font color="red">数据域</font>可以为空，也可以存放线性<font color="red">表长度</font>等附加信息，但此结点不能计入链表长度



#### <font color="red">链表（链式存储结构）的特点</font>

1. 结点在存储器中的位置是任意的，即在逻辑上相邻的元素在物理上不一定相邻
2. 访问时只能通过头指针访问链表，并通过每个结点的指针域依次向后扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等

这种数据元素的存储方法称为<font color="red">顺序存取法</font>



#### 单链表的定义和表示

单链表是<font color="red">由表头</font>唯一确定，因此单链表可以用<font color="red">头指针</font>的名字来命名，若头指针名是L，则把链表称为<font color="red">表L</font>。

**单链表的存储结构：**

```c++
typedef struct Lnode{
	ElemType data;
	struct Lnode *next;
}Lnode,*LinkList;
```

虽然LinkList X 和 Lnode *X 都能表示新建一个指针，但一般用<font color="red">LinkList L 创建链表</font>，用<font color="red">Lnode *p 来创建指向结点的指针</font>。



### 🎵单链表基本操作的实现

#### 单链表的初始化

```c++
Status InitList_L(LinkList &L){
	L = new LNode;   //从内存中申请一个存放LNode类型的空间，L指向它
	L->next = NULL;
	return OK;
}
```

#### 判断链表是否为空

```c++
int ListEmpty(LinkList L){	//若表为空，返回1；不为空，返回0
	if(L->next)
		return 0;	//非空
	else
		return 1;
}
```

#### 单链表的销毁

从头指针开始，依次释放所有结点

用一个指针p来同样指向头指针L所指的结点，然后L往后移一位，p负责删除L上一个指向的结点并重新指向L当前所指的结点，这样重复直到所有结点都被释放。

```c++
Status DestoryList_L(LinkList &L){
	LNode *P;
	while(L){
		p = L;
		L = L->next;
		delete p;
	}
    return OK;
}
```

#### 清空单链表

链表仍存在，但链表中没有元素，只有头指针和头结点

```c++
Status ClearList(LinkList &L){
	Lnode *p, *q;
	p = L->next;	//p指向首元结点
	while(p){
		q = p->next;
		delete p;
        p = q;
	}
	L->next = NULL;	//头结点的指针域指向空
    return OK;
}
```

#### 求单链表表长

* 头结点不计入

```c++
int ListLength_L(LinkList L){
	Lnode *p;
	int i = 0;
	p = L->next;
	while(p){
		i++;
		p = p->next;
	}
	return i;
}
```

#### 单链表取值

```c++
Status GetElem_L(LinkList L;int i;ElemType &e){
	Lnode *p;p = L;int j = 0;	//初始化
	while(p && j<i){
		p = p->next;
		j++;
	}
	if(!p || j>i) return ERROR;	//这里j>i是指i为0或者负数的情况 !p有两种情况
	e = p->data;				//1.链表为空  2.i的值大于链表长度p指向空了		
	return OK;
}
```

#### 单链表的按值查找

返回指针（地址）

```c++
Lnode *LocateElem_L(LinkList L,ElemType e){
	Lnode *p;p = L->next;
	while(p && p->data != e){
		p = p->next;
	}
	return p;
}
```

返回<font color="red">位置序号</font>

```c++
int LocateElem_L(LinkList L,Elemtype e){
	Lnode *p;p = L;int j = 0;
	while(p && p->data != e){
		p = p->next;
		j++;
	}
	if(p) return j;
    else return 0;
}
```

#### 单链表的插入

```c++
Status ListInsert_L(LinkList &L,ElemType e,int i){
	Lnode *p;p = L;int j = 0;
	while(p && j<i){
		p = p->next;
		j++;
	}
	if(!p || j>i) return ERROR;
	
	s = new Lnode;s->data = e;	//这里一定要用new一块内存空间 如果只Lnode一个结点
	s->next = p->next;			//只是一个函数中的临时变量
	p->next = s;
	
	return OK;
}
```

单链表的删除

```c++
Status ListDelete_L(LinkList &L,int i,ElemType &e){
	Lnode *p;p = L;int j = 0;Lnode *q;
	while(p && j<i-1){
		p = p->next;
		j++;
	}
	if(!p || j>i-1) return ERROR;
	
	q = p->next;
	e = p->next->data;
	p->next = p->next->next;
	delete q;
	return OK;
}
```



#### 单链表的查找、插入、删除算法时间效率分析

1. 查找：线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为<font color="red">O（n）</font>
2. 插入和删除：不需要移动元素，只要修改指针，一般情况下时间复杂度为<font color="red">O（1）</font>，但是如果在不知道插入或删除的位置情况下需要查找，时间复杂度为<font color="red">O（n）</font>



#### 建立单链表

* 头插法：元素插在链表的头部(倒位序)

```c++
void CreateList_H(LinkList &L,int n){
	Lnode *p;
	L = new Lnode;
	L->next = NULL;
	
	for(i=n;i>0;i--){
		p = new Lnode;
		cin>>p->data;
		p->next = L->next;
		L->next = p;
	}
}
```

* 尾插法：元素插在链表的尾部(正位序)

```c++
void CreateList_R(LinkList &L,int n){
	Lnode *p;Lnode *r;		//需要创建一个指针来指向尾结点
    L = new Lnode;L->next = NULL;
    r = L;
	
    for(i=0;i<n;i++){
        p = new Lnode;
        cin>>p->data;
        p->next = NULL;
        r->next = p;
        r = p;
    }
}
```



### 🎵循环链表

定义：是一种头尾相接的链表（表中最后一个结点指向<font color="red">头结点</font>）

优点：可以从表中任意结点出发均可找到表中其他结点

注意：

1. 由于循环链表没有NULL指针，故涉及遍历操作时，其终止条件不再像非循环链表那样判断p或者p->next是否为空，而是<font color="red">判断它们是否等于头指针</font>

```
p != L;
p->next != NULL;
```

2. 表的操作常常是在表的首尾进行

   若用头指针表示单循环链表，寻找a~n~的时间复杂度为O（n），不方便

   所以经常用尾指针来表示单循环链表,使得寻找a~1~和a~n~的时间复杂度都为O（1）

   a~1~的存储位置：R->next->next

   a~n~的存储位置：R



**带尾指针的循环链表的合并**

```c++
LinkList Connect(LinkList Ta,LinkList Tb){
	p = Ta->next;				//存储表头结点
	Ta->next = Tb->next->next;	//Tb表头连接Ta表尾
	delete Tb->next;			//释放Tb表头结点
	Tb->next = p;				//修改指针
	return Tb;					//因为return了新的表尾  所以形参不用引用符号
}
```



### 🎵双向链表

定义：在每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中有两个方向不同的链，称为双向链表

双向链表的结构可定义如下：

```
typedef struct DuLnode{
	ElemType data;
	struct DuLnode *prior,*next;
}DuLnode,*DuLinkList;
```

#### 双向链表的插入

```c++
void ListInsert_DuL(DuLinkList &L,int i,ElemType e){
	if(!(p = GetElemP_DuL(L,i))) return ERROR;	//用p指向第i个结点
	DuLnode *s;
	s = new DuLnode;
	s->data = e;
	
	s->prior = p->prior;
	p->prior->next = s;
	s->next = p;
	p->prior = s;
	
	return OK;
}
```

#### 双向链表的删除

```c++
void ListDelete_DuL(DuLinkList &L,int i,ElemType &e){
	if(!(p = GetElemP_DuL(L,i))) return ERROR;	//寻找第i个元素的时间复杂度O(n)
	e = p->data;
	p->prior->next = p->next;	//删除元素所需要的时间复杂度为 O(1)
	p->next->prior = p->prior;
	delete p;
	return OK;
}
```

### 🎵单链表、循环链表和双向链表的时间效率比较

|                                   | 查找首元结点           | 查表表尾结点                         | 查找结点*p的前驱结点                   |
| --------------------------------- | ---------------------- | ------------------------------------ | -------------------------------------- |
| 带头结点的单链表L                 | L->next 时间复杂度O(1) | 从L->next依次向后遍历 时间复杂度O(n) | 通过p->next无法找到前驱                |
| 带头结点且仅设头指针L的循环单链表 | R->next 时间复杂度O(1) | 从L->next依次向后遍历 时间复杂度O(n) | 通过p->next可以找到前驱 时间复杂度O(n) |
| 带头结点且仅设尾指针R的循环单链表 | R->next 时间复杂度O(1) | R 时间复杂度O(1)                     | 通过p->next可以找到前驱 时间复杂度O(n) |
| 带头结点的双向循环链表            | R->next 时间复杂度O(1) | R 时间复杂度O(1)                     | p->prior 时间复杂度O(1)                |

* 带头结点的双向循环链表，本质上还是用空间换取时间效率



### 🎵线性表的应用

#### 线性表的合并

思路：依次取出Lb中的每个元素，在La中查找该元素，如果找不到，插入到La表的最后

```c++
void union(SqList &La,SqList Lb){
	La_len = ListLength(La);
	Lb_len = ListLength(Lb);
	
	for(i=1;i<=Lb_len;i++){
		GetElem(Lb,i,e);
		if(!LocateElem(La,e)) ListInsert(&La,++La_len,e);
	}
}
```

* 算法的时间复杂度为 O( ListLength(La) * ListLength(Lb) )



#### 有序表的合并

* 顺序表的实现

```c++
void MergeList_Sq(SqList La,SqList Lb,SqList &Lc){
	ElemType *pa,*pb,*pc;
	ElemType *La_last,*Lb_last;				//指针类型要和元素类型对应
	pa = La.elem;							//分别指向两个顺序表第一个元素的指针
	pb = Lb.elem;
	
	Lc.length = La.length + Lb.length;
	Lc.elem = new ElemType[Lc.length];		//为新表分配一个数组空间
	pc = Lc.elem;
	
	pa_last = La.elem + La.length - 1;		//分别指向表中的最后一个元素
	pb_last = Lb.elem + Lb.length - 1;
	
	while(pa <= pa_last && pb <= pb_last){	//两个表都非空
		if(*pa <= *pb) *pc++ = *pa++;
		else *pc++ = *pb++;
	}
	
	while(pa <= pa_last) *pc++ = *pa++;		//将剩余元素填入表c
    while(pb <= pb_last) *pc++ = *pb++;
	
}
```

算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )     比较步骤和剩余填入步骤 之和

算法的空间复杂度：O( ListLength(La) + ListLength(Lb) ) 

* 链表实现

```c++
void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc){
	Lnode *pa,*pb,*pc;
	pa = La->next;	pb = Lb->next;		//分别指向La和Lb的首元结点
	pc = Lc = La;	//用La的头结点作为Lc的头结点 pc是表Lc中指向最后一个元素的指针
	
	while(pa && pb){
		if(pa->data <= pb->data){pc->next = pa; pc = pa; pa = pa->next;}
		else(pc->next = pb; pc = pb; pb = pb->next;)
	}
	//当La和Lb有一个表填完
	pc->next = pa ? pa:pb;
	
	//释放Lb的头结点
	delete Lb;
}
```

算法的时间复杂度：O( ListLength(La) + ListLength(Lb) )        计算的是最坏情况下的

算法的空间复杂度：O(1) 不需要额外的空间，修改La和Lb指针得到

### **🎵补充**

#### **数组定义**

数组静态分布

```c++
typedef struct{
	ElemType data[maxsize];
	int length;
}SqList;
```

数组动态分布

```c++
typedef struct{
	ElemType *data;	//数组的名字存放的是数组的首地址，所以也可以直接定义一个指针变量
	int length;		//来存放数组的首地址
}SqList;

SqList L;
L.data = (ElemType*)malloc(sizeof(ElemType)*maxsize);
```

#### **C语言动态存储分配**

对于c来说 (ElemType*)malloc(m) ，后面的括号是申请的内存空间的大小，前面的括号是强制转换类型，即将申请的空间转换成什么类型，并返回申请空间的首地址，由指针指向这个首地址。删除用free()。

<font color="red">需要加载头文件：<stdlib.h></font>(C语言)



#### **C++的动态存储分配**

``new 类型名T(初值列表)``

功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值

成功：T类型的指针，指向新分配的内存

失败：0（NULL）

```c++
int *p1 = new int;		//不赋初值
int *p1 = new int(10);	//赋初值
```

``delete 指针p``

功能：释放指针P所指向的内存。P必须是new操作的返回值。



#### **C++中的参数传递**

* 函数调用时传送给形参的实参必须与形参三个一致：类型、个数、顺序
* 参数传递有两种方式
  * 传值方式（参数为整型、实型、字符型等）
  * 传地址
    * 参数为指针变量
    * 参数为引用类型
    * 参数为数组名



#### **C++中 引用类型做参数**

```c++
void main()
{
	int i = 5;
	int &j = i;		//引用类型,j作为i的一个替代名字，会随着i的改变而改变
	i = 7;
}


void swap(float &m,float &n) //这里的m和n与主函数中的实参用的是同一块空间
{
    float temp;
    temp = n;
    n = m;
    m = temp;
}
```



#### **引用类型做形参的三种说明**

1. 传递引用给函数与传递指针的效果是一样的，<font color="red">形参变化实参也发生变化</font>。

2. 引用类型做形参，在内存中并没有产生实参的副本，它<font color="red">直接对实参操作</font>；而一般变量作参数，形参与实参就占用不同的存储单元，所以<font color="red">形参变量的值是实参变量的副本</font>。因此，当<font color="red">参数传递的数据量较大</font>时，用引用比用一般变量传递参数的时间和空间效率都好。
3. 指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。





## 栈和队列

### 栈和队列的定义和特点

* 栈和队列是两种常用的、重要的数据结构
* 栈和队列是限定插入和删除只能在表的 “端点” 进行的线性表

栈

```c++
Insert(s,n+1,x)	//插入和删除只能在表尾进行
Delete(s,n)
```

队列

```c++
Insert(q,n+1,x)	//插入在表尾进行
Delete(q,1)		//删除在表头进行
```



### 栈的定义和特点

栈(stack)是一个特殊的线性表，是限定仅在一端进行插入和删除操作的数据表

又称为<font color="red">后进先出</font>(Last In First Out)的线性表，简称<font color="red">LIFO</font>结构。



**栈的相关概念**

* 表尾（即a~n~端）称为<font color="red">栈顶</font>Top；表头（即a~1~端）称为<font color="red">栈底</font>Base

* 插入元素到栈顶（即表尾）的操作，称为<font color="red">入栈</font>		PUSH

* 从栈顶删除一个元素的操作，称为<font color="red">出栈</font>					POP

* 逻辑结构：与线性表相同，仍为一对一关系
* 存储结构：用顺序栈或链栈均可，但以顺序栈更常见
* 运算规则：只能在栈顶运算，且访问结点时依照后进先出的原则
* 实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈和链栈的不同而不同

<font color="red">与线性表的区别：</font>仅在于运算规则不同，一个随机存取，一个后进先出



### 队列的定义和特点

队列(queue)是一种<font color="red">先进先出</font>(First In First Out)的线性表。在表尾插入，在表头删除



**队列的相关概念**

* 逻辑结构：一对一
* 存储结构：顺序队或链队，以循环队列更常见
* 运算规则：只能在队首或队尾运算，且访问结点时依照先进先出原则
* 实现方式：关键是掌握入队和出队操作，且具体实现依顺序队或链队的不同而不同





### 栈的表示和实现

#### 栈的抽象数据类型的类型定义

```c++
ADT Stack{
	数据对象:
		D = {ai|ai∈ElemSet,i=1,2,3....n,n>=0}
	数据关系：
		R1 = {<ai-1,ai>|ai-1,ai∈D,i=2,3,4...n}
		约定an为栈顶，a1为栈底
	基本操作：
		初始化、进栈、出栈、取栈顶元素等
}ADT Stack
```



#### 🍨顺序栈的表示和实现

存储方式：同线性表的顺序存储结构相同，用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址端。

* 附设<font color="red">top</font>指针，指示栈顶元素在顺序栈中的位置
* 另设<font color="red">base</font>指针，指示栈底元素在顺序栈中的位置

<font color="red">但是为了方便操作，通常top指针指示真正的栈顶元素之上的下标地址</font>

* 另外，用<font color="red">stacksize</font>表示栈可用的最大容量



空栈：base == top 是栈空标志

栈满：top - base == stacksize

栈满时的处理方法：

1. 报错，返回操作系统
2. 分配更大内存空间，作为栈的存储空间，将原栈的内容移入新栈



使用数组作为顺序栈存储方式的特点：

简单、方便，但易产生溢出

* 上溢(overflow)：栈已经满，又要压入元素
* 下溢(underflow)：栈已经空，又要弹出元素



顺序栈的表示

```c++
#define MAXSIZE 100
typedef struct{
	SElemType *top;
	SElemType *base;
	int stacksize;
}SqStack;
```



##### 顺序栈的初始化

```c++
Status InitStack(SqStack &S){
	S.base = new SElemType[MAXSIZE];	//分配内存空间
	if(!S.base) exit(OVERFLOW);			//如果分配失败
	
	S.top = S.base;						//栈顶指针等于栈底指针
	S.stacksize = MAXSIZE;
	return OK;
}
```



##### 顺序栈判断栈是否为空

```c++
Status StackEmpty(SqStack s){
	if(S.top == S.base)
		return TRUE;
	else
		return FALSE;
}
```



##### 求顺序栈长度

```c++
int StackLength(SqStack S){
	return S.top-S.base;
}
```



##### 清空顺序栈

```c++
Status ClearStack(SqStack S){
	if(S.base) S.top == S.base;	//如果没有base就不用清空了；不用删除元素，令栈顶指
	return OK;					//针等于栈底指针就相当于栈为空
}
```



##### 销毁顺序栈

```c++
Status DestoryStack(SqStack &s){
	if(S.base){
		delete S.base;
		S.stacksize = 0;
		S.top = S.base = NULL;
	}
	return OK;
}
```



##### 顺序栈的入栈

```c++
Status Push(SqStack &S,SElemType e){
	if(S.top-S.base == stacksize) return ERROR;
	
	*S.top++ = e;
	return OK;
}
```



##### 顺序栈的出栈

```c++
Status Pop(SqStack &S,SElemType &e){
	if(S.top == S.base)
		return ERROR;
	e = *--S.top;
	return OK;
}
```





#### 🍨链栈的表示

* 链栈是<font color="red">运算受限</font>的单链表，只能在<font color="red">链表头部</font>进行操作

```c++
typedef struct StackNode{
	SElemType data;
	struct StackNode *next;
}StackNode,*LinkStack;
LinkStack S;
```

* 链表的头指针就是栈顶
* 不需要头结点
* 基本不存在栈满的情况
* 空栈相当于头指针指向空
* 插入和删除仅在栈顶处执行



##### 链栈的初始化

```c++
void InitStack(LinkStack &S){
	//构造一个空栈，栈顶指针置为空
	S = NULL;
	return OK;
}
```



##### 判断链栈是否为空

```c++
Status StackEmpty(LinkStack S){
	if(S == NULL) return TRUE;
	else return FALSE;
}
```



##### 链栈的入栈

```c++
Status Push(LinkStack &S,SElemType e){
	StackNode *p;
	p = new StackNode;
	p->data = e;
	p->next = S;
	S = p;
	return OK;
}
```



##### 链栈的出栈

```c++
Status Pop(LinkList &S,SElemType &e){
	if(S == NULL) return ERROR;
	e = S->data;
	
	Stacknode *p;
	p = S;
	S = S->next;
	delete p;
	return OK;
}
```



##### 取栈顶元素

```c++
SElemType GetTop(LinkStack S){
	if(S != NULL) 
	return S->data;
}
```





### 栈与递归

#### 递归的定义

* 若一个对象部分地<font color="red">包含它自己</font>，或者用它<font color="red">给自己定义</font>，则称这个对象是递归的
* 若一个过程<font color="red">直接或间接地调用自己</font>，则称这个过程是递归过程

#### 以下这三种情况常常用到递归方法

1. 递归定义的数学函数
   * 阶乘函数
   * 斐波那契数列
2. 具有递归特性的数据结构
   * 二叉树
   * 广义表
3. 可递归求解的问题
   * 迷宫问题
   * 汉诺塔问题

#### 递归问题：用分治法求解

分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解

必备的三个条件：

1. 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的的仅是处理的对象，且这些处理对象是变化有规律的
2. 可以通过上述转化而使问题简化
3. 必须有一个明确的递归出口，或称递归边界



#### 分治法求解递归问题算法的一般形式

```c++
void p(参数表){
	if(递归结束条件) 可直接求解步骤;	//基本项
	else p (较小的参数);	//归纳项
}
```



#### 函数调用过程

调用前，系统完成：

1. 将<font color="red">实参，返回地址</font>等传递给被调用函数
2. 为被调用函数的<font color="red">局部变量</font>分配存储区
3. 将控制转移到被调用函数的<font color="red">入口</font>

调用后，系统完成：

1. 保存被调用函数的计算<font color="red">结果</font>
2. 释放被调用函数的<font color="red">数据区</font>
3. 依照被调用函数保存的<font color="red">返回地址</font>将控制转移到调用函数



#### 多个函数嵌套调用

<font color="red">遵循后调用的先返回</font>



#### 递归函数调用的实现

“层次”

```
主函数		 0层
第1次调用	1层
......		
第i次调用	i层
```

“递归工作栈”	——递归程序运行期间使用的数据存储区

“工作记录”		实际参数、局部变量、返回地址



#### 递归的优缺点

优点：结构清晰，程序易读

缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。



递归——>非递归

方法1：尾递归、单向递归 ——>循环结构

方法2：自用<font color="red">栈</font>模拟系统的运行时候栈



### 队列的表示和操作的实现

#### 队列的抽象数据类型定义

```
ADT Queue{
	数据对象：D = {ai|ai∈Elemset,(i=1,2,...,n,n>=0)}
	数据关系：R = {<ai-1,ai>|ai-1,ai∈D,(i=2,3,...n)}    //这里的ai中的i都是下标
	基本操作：
		InitQueue(&Q);
		DestroyQueue(&Q);
		......
}ADT Queue
```



#### 队列的顺序表示和实现

用一维数组base[MAXQSIZE]

```c++
#define MAXQSIZE 100
typedef struct{
	QElemType *base;	//指向数组首地址
	int front;			//头指针 虽然叫做指针但不是指针变量，指的是数组中的下标
	int rear;			//尾指针
}
```



**解决假上溢的方法：**

1. 将队中元素依次向队头方向移动

   缺点：浪费时间。每移动一次，队中元素都要移动

2. 将队空间设想成一个循环的表，当rear或front等于maxsize时，若开始端空着，可以从头使用空着的空间

base[0]接在base[MAXQSIZE - 1]之后，若rear + 1 == M，则令rear = 0；

实现方法：利用<font color="red">模运算（mod,c语言中：%）</font>



**区分队空和队满**

1. 另外设置一个标志来区分队空、队满

2. 另设一个变量，记录元素个数

3. <font color="red">少用一个元素空间</font>

   用第三种方法时：

   队空：front == rear

   队满：（rear+1）% MAXQSIZE == front			//无论对front下标在哪都适用



##### 队列的初始化

```c++
Status InitQueue(SqQueue &Q){
	Q.base = new QElemType[MAXQSIZE];
	if(!Q.base) exit(OVERFLOW);
	Q.front = Q.rear = 0;
	return OK;
}
```



##### 求队列的长度

```c++
int QueueLength(SqQueue &Q){
	return((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);
}
```



##### 循环队列入队

```c++
Status EnQueue(&Q,QElemType e){
	if( (Q.rear+1) % MAXQSIZE == Q.front) return ERROR;
    Q.base[Q.rear] = e;
	Q.rear = (Q.rear + 1) % MAXQSIZE;
    return OK;
}
```



##### 循环队列出队

```c++
Status DeQueue(&Q,&QElemType e){
	if(Q.front == Q.rear) return ERROR;
	e = Q.base[Q.front];
	Q.front = (Q.front + 1) % MAXQSIZE;
	return OK;
}
```



##### 取队头元素

```c++
QElemType GetHead(Q){
	if(Q.front != Q.rear)	return Q.base[front];
}
```



#### 队列的链式表示和实现

若用户无法估计所用队列的长度，宜采用链队列

* 带头结点



##### 链队列的类型定义

```c++
#define MAXQSIZE 100
typedef struct Qnode{
	QElemType data;
	struct Qnode *next;
}Qnode,*QueuePtr;

typedef struct{
    QueuePtr front;		//头指针
    QueuePtr rear;		//尾指针
}LinkQueue;
```



##### 链队列初始化

```c++
Status InitQueue(LinkQueue &Q){
	Q.front = Q.rear = new Qnode;
	if(!Q.front) exit(OVERFLOW);
	Q.front->next = NULL;
	return OK;
}
```



##### 链队列的销毁

```c++
Status DestroyQueue(LinkQueue &Q){
	Qnode *p;
	while(Q.front){
		p = Q.front->next;
		delete Q.front;
		Q.front = p;
	}//这里Q.rear 没什么用，可以直接用它来代替p
	return OK;
}
```



##### 链队列入队

```c++
Status EnQueue(LinkQueue &Q,QElemType e){
	Qnode *p;
	p = new Qnode;
    if(!p) exit(OVERFLOW);
	p->data = e;
	p->next = NULL;
	
	Q.rear->next = p;
    Q.rear = p;
	return OK;
}
```



##### 链队列出队

```c++
Status DeQueue(LinkQueue &Q,QElemType &e){
	if(Q.front == Q.rear) return ERROR;
	Qnode *p;
	p = Q.front->next;
	e = p->data;
	Q.front->next = Q.front->next->next;
	
	if(Q.rear == p) Q.rear = Q.front;	//如果恰好删除的是尾结点，那么尾指针也指向
										// 头结点
	delete p;
	return 
}
```



##### 求链队列队头元素

```c++
Status GetHead(LinkQueue Q,QElemType &e){
	if(Q.front == Q.rear) return ERROR;
	e = Q.front->next->data;
	return OK;
}
```





## 串

### 串的定义

串（string）：零个或多个任意字符组成的有限序列

s = “a~1~a~2~···a~n~” (n>=0)

串名：s

串值：a~1~到a~n~

串长：n

空串：n=0	用∅表示

子串：串中任意个连续字符组成的子序列称为该串的子串

真子串：不包含自身的所有子串

主串：包含子串的串

字符位置：字符在序列中的序号为该字符在串中的位置

子串位置：子串中第一个字符在主串中的位置

空格串：由一个或多个空格所构成的串，与空串不同

串相等：当且仅当两个串长度相等且各个对应位置上的字符都相同，这两个串才相等

​				所有的空串都是相等的



### 串的类型定义

```
ADT String{
	数据对象：字符
	数据关系：序偶关系
	基本操作：
		1.串赋值
		2.串比较
		3.求串长
		4.串连结
		5.求子串
		6.串拷贝
		7.清空串
		8.串判空
		9.子串的位置
		10.串替换
		11.子串插入
		12.子串删除
		13.串销毁
}ADT String
```



### 串的存储结构

串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构（顺序、链式）

#### 串的顺序存储结构

```c++
#define MAXLEN 255
typedef struct{
	char ch[MAXLEN+1];	//0号位置不用
	int length;
}SString
```



#### 串的链式存储结构

与单链表类似	优点：操作方便		缺点：存储密度较低

为了克服缺点，可将多个字符放在一个结点中，称为<font color="red">块</font>

```
#define CHUNKSIZE 80
typedef struct Chunk{
	char ch[CHUNKSIZE];
	struct Chunk *next;
}Chunk;

typedef struct{
	Chunk *head,*tail;	//串的头指针和尾指针
	int curlen;			//串的当前长度
}LString;				//字符串的块链结构
```



### 串的模式匹配算法

算法目的：确定主串中所含子串（模式串）第一次出现的位置

算法应用：搜索引擎、拼写检查、语言翻译、数据压缩

算法种类：BF算法、KMP算法



#### BF算法

简单匹配算法，采用穷举法的思路

算法的思路是从S（正文串）的每一个字符开始依次与T（模式）的字符进行匹配



##### 设计思想

Index (S,T,pos)

* 将主串的第pos个字符和模式串的第一个字符比较
* 若相等，继续逐个比较后续字符
* 若不等，从主串的下一字符起，重新与模式串的第一个字符比较
* 直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的第一个子序列的第一个字符的序号，即匹配成功
* 否则，匹配失败，返回值为0



##### 算法描述

```c++
int Index_BF(SString S,SString T，int pos){	//pos是从什么位置开始寻找
	int i=pos,j=1;
	
	while(i<=S.length && j<=T.length){
		if(S.ch[i] == T.ch[j])	{++i;++j;}	//主串和子串依次匹配下一个字符
		else {j = 1; i = i - j + 2;}		//主串、子串回溯开始下一次匹配
	}
	if(j>T.length) return i-T.length;		//匹配成功返回第一个字符的下标
	else return 0;							//匹配失败
}
```



##### 算法时间复杂度

主串长度为n，子串长度为m

最好情况：O（m）

最坏情况：O [ (n-m)*m + m ]	若 m<<n，则算法复杂度为 O (m * n)



#### KMP算法

该算法较BF有较大改进，从而算法效率有了某种程度的提高



##### 算法思想

利用已经<font color="red">部分匹配</font>的结果而加快模式串的滑动速度

且主串S的指针<font color="red">i不必回溯</font>，可提速到<font color="red">O（m+n）</font>



##### next[j]数组

表明当模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的位置

​					max	

next [j] = 	0	当j=1时

​					1	其他情况



##### 算法描述

```c++
int Index_KMP(SString S,SString T，int pos){
	int i=pos,j=1;
	
	while(i<=S.length && j<=T.length){
		if(S.ch[i] == T.ch[j])	{++i;++j;}	
		else 	j = next[j];		//i不变，j后退 （与BF算法的区别）
	}
	if(j>T.length) return i-T.length;
	else return 0;			
}
```

获得next[j]数组的函数

```c++
void get_next(SString T,int &next[]){
	i = 1;next[1] = 0;j = 0;
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j]){
			++i;++j;
			next[i] = j;  //如果i和j向后移一位后ch[i]和ch[j]相等，next[i]直接加1
		}
		else j = next[j]; //如果不相等，变成重新再找前j个字符的最长公共前缀子串，再						  //移下一位看是否相等
	}
}
```

理解：

[(7条消息) KMP算法原理描述，告诉你为什么要“j = next[j\]”_Leycaner的博客-CSDN博客_j=next[j]](https://blog.csdn.net/Leycaner/article/details/108301195)



##### next函数的改进

```c++
void get_nextval(SString T,int &nextval[]){
	i = 1;nextval[1] = 0;j = 0;
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j]){
			++i;++j;
			if(T.ch[i]!=T.ch[j]) nextval = j;
			else nextval[i] = nextval[j];
 		}
		else j = nextval[j]; 
	}
}
```



## 数组

按一定格式排列起来的具有<font color="red">相同类型</font>的数据元素的集合

**结论：**线性表是数组结构的一个特例，而数组结构又是线性表结构的扩展

**特点：**结构固定

**数组基本操作：**除了结构的初始化和销毁之外，只有取元素和修改元素值的操作



### 数组的抽象数据类型定义

<font color="red">n维数组</font>的抽象数据类型

ADT Array{

​	数据对象： j~i~ = 0,······,b~i~-1	i = 1,2,······n				n为数组的维数，b~i~为数组第i维的长度

​						D = {a~j1j2······jn~|a~j1j2······jn~ ∈ElemSet}

​	数据关系：

​						R1 = {<a~j1······ji······jn~，a~j1······ji+1······jn~>|0<=j~k~<=b~k~-1 , 1<=k<=n, 且k≠i, 0<=j~i~<=b~k~-2,

​									<a~j1······ji······jn~，a~j1······ji+1······jn~>∈D ,i = 2,······,n}

}



基本操作

```
1.InitArray(&A,n,bound1,...boundn)		//n是维数，boundn是每一维的上界
2.DestoryArray(&A)
3.Value(A,&e,index1,...indexn)
4.Assign(A,&e,index,...indexn)
}ADT Array
```



### 数组的顺序存储

数组特点：结构固定

数组基本操作：初始化、销毁、取元素、修改元素值。一般不做插入和删除操作

<font color="red">所以：</font>一般都是用<font color="blue">顺序存储结构</font>来表示数组

注意：数组可以是多维的，但是存储数据元素的内存地址单元是一维的



**一维数组**

​					LOC(0) = a							i = 0

LOC（i）=  

​					LOC(i-1) + L = a + i * L,		i > 0



**二维数组**

两种存储方式：

1. 以行序为主序		LOC( i , j ) = LOC ( 0 , 0 ) + ( n * i  + j ）* L 			n列数  m行数
2. 以列序为主序        LOC( i , j ) = LOC ( 0 , 0 ) + ( i + j * m ) * L 



**三维数组**

按 页/行/列 存放，页优先的顺序存储

a[m1] [m2] [m3] 各维元素个数为m1,m2,m3

下标为i~1~,i~2~,i~3~的数组元素的存储位置

LOC ( i~1~,i~2~,i~3~ ) = a + i~1~ * m2 * m3 + i~2~ * m3 + i~3~





### 特殊矩阵的压缩存储

矩阵的常规存储：描述为二维数组

矩阵的常规存储的特点：可以随机存取；运算简单；存储密度为1

不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多

矩阵的压缩存储：为多个相同的非零元素只分配一个空间；对零元素不分配空间

1. 什么是压缩存储

   若多个数据元素的<font color="red">值都相同</font>，则只分配一个元素值的存储空间，且零元素不占存储空间

2. 什么样的矩阵能够压缩

   一些特殊矩阵，如：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵等

3. 什么叫稀疏矩阵

   矩阵中非零元素很少（一般少于5%）



#### 对称矩阵

**特点：**对角线上下两边都对称，即a~ij~ = a~ji~  (1<=i,j<=n)

**存储方法：**只存储上（或下）三角（包括主对角线）的元素，占用 n(n+1)/2 的存储空间

**存储结构：**

可以<font color="red">以行序为主序</font>将元素存储在一维数组 sa[ n(n+1)/2 ]中

一维数组中的元素，它前面有多少个元素它就在第几个位置

假如求 a~ij~ 在一维数组中的位置   ( i - 1 + 1) *( i-1)/2  +  j - 1	（下三角）



#### 三角矩阵

**特点：**对角线以下（或者以上）的数据元素（不包括对角线）全部为常数c

**存储方法：**重复元素c共享一个元素存储空间，共占用 n(n+1)/2 + 1 个元素空间

​					类似于对称矩阵



#### 对角矩阵

**特点：**所有元素都集中在以主对角线为中心的带状区域中，区域外的值为0，称为<font color="red">对角矩阵</font>

**存储方法：**用二维数组存储，每一个对角线上的所有元素存储为一行

|      |  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  -2  |      |      |  3   |  3   |  8   |  5   |
|  -1  |      |  2   |  0   |  6   |  1   |  2   |
|  0   |  8   |  2   |  7   |  9   |  4   |  3   |
|  1   |  4   |  7   |  6   |  1   |  8   |      |
|  2   |  5   |  9   |  6   |  2   |      |      |

其中主对角线存储在行标为0的行中



#### 稀疏矩阵

三元组法：三元组（i，j，a~ij~）唯一确定矩阵的一个非零元

矩阵由所有三元组和矩阵维数（m，n）唯一确定

**压缩存储原则：**存各非零元的值、行列位置和矩阵的行列数



1、顺序存储结构：三元组顺序表

|      | i（行数） |  j（列数）  |     v（元素值）     |
| :--: | :-------: | :---------: | :-----------------: |
|  0   | 6(总行数) | 6（总列数） | 8（非零元素总个数） |
|  1   |     1     |      2      |         12          |
|  2   |     1     |      3      |          9          |
|  3   |     3     |      1      |         -3          |

三元组顺序表又称<font color="red">有序的双下标法</font>

优点：非零元在表中按行序有序存储，因此<font color="red">便于进行依行顺序处理的矩阵运算</font>

缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始查找



2.链式存储结构：十字链表

优点：能够<font color="red">灵活地插入</font>因运算而产生的新的非零元素，<font color="red">删除</font>因运算产生的新的零元素，实现矩阵的各种运算。

表示：每一个非零元素用一个结点表示，该结点有五个域（row，col，value，right，down）

right：用于链接同一行中的下一个非零元素

down：用于链接同一列中的下一个非零元素

| 头结点  | M.chead |      |      |      |
| :-----: | :-----: | :--: | :--: | :--: |
| M.rhead |  结点   |      |      | 结点 |
|         |         | 结点 |      |      |
|         |  结点   |      |      |      |







## 广义表

广义表（又称列表List）是n个元素的有限序列，其中每一个a~i~或者是<font color="red">原子</font>或者是一个<font color="red">广义表</font>

拓宽了的线性表就是广义表。



### 广义表的定义

* 广义表通常记作：LS = （a~1~,a~2~,……,a~n~）

​	其中：LS为表名，n为表的长度，每一个a~i~为表的元素

* 习惯上，一般用大写字母表示广义表，小写字母表示原子
* 表头：若LS非空，则其第一个元素a~1~就是表头，记作head（LS） = a~1~ <font color="red">注：</font>表头可以是原子或子表
* 表尾：除表头之外<font color="red">其他元素</font>组成的表，记作tail（LS） = （a~2~,……,a~n~） <font color="red">注：</font>表尾不是最后一个元素，而是一个子表



### 广义表的性质

1. 广义表中的数据元素有相对 <font color="red">次序</font>；一个直接前驱和一个直接后继
2. 广义表的<font color="red">长度</font>定义为最外层所包含元素的个数
3. 广义表的<font color="red">深度</font>定义为该广义表 <font color="blue">展开后所含括号的重数；</font>  <font color="red">注：</font>“原子”的深度为0；“空表”的深度为1
4. 广义表可以为其他广义表<font color="red">共享</font>
5. 广义表可以是一个 <font color="red">递归</font>的表。<font color="red">注：</font>递归表的深度是无穷值，长度是有限值
6. 广义表是<font color="red">多层次</font>结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表



### 广义表和线性表的区别

广义表可以看成是线性表的推广，线性表是广义表的特例

广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、数和有向图等各种常用的数据结构



### 广义表的基本运算

1. 求表头GetHead（L)，可以是一个原子也可以是一个子表
2. 求表尾GetTail（L)，一定是一个子表



### 广义表的存储

因为表中元素的大小不固定，所以不用数组存储，一般用链表存储





## ⛄树和二叉树

### 树的定义

树（Tree）是n（n>=0）个结点的有限集（递归定义）。

若n=0，称为空树；

若n>0，则它满足如下两个条件：

	1. 有且仅有一个特定的称为 根 的结点
	2. 其余结点可以分为m个互不相交的有限集T1，T2，T3······Tm，其中每一个集合本身又是一棵树，并称为根的子树（SubTree）
	3. 





### 树的基本术语

结点：数据元素以及指向子树的分支

根节点：非空树中无前驱结点的结点

结点的度：结点拥有的子树数

树的度：树内各结点的度的最大值

叶子结点：度为0，也叫作终端节点

分支结点：度不为0，非终端结点

内部结点：根节点以外的分支结点

结点的子树称为该结点的<font color="red">孩子</font>，该结点称为孩子的<font color="red">双亲</font>

拥有同一个双亲的结点称为<font color="red">兄弟结点</font>

双亲在同一层但双亲不同的结点称为<font color="red">堂兄弟结点</font>

结点的<font color="red">祖先</font>：从根到该结点所经分支上的所有结点

结点的<font color="red">子孙</font>：以某结点为根的子树中的任一结点

树的<font color="red">深度</font>：树中结点的最大层次

<font color="red">有序树：</font>树中结点的各子树从左至右有次序（最左边为第一个孩子）

<font color="red">无序树：</font>树中结点的各子树无次序

<font color="red">森林：</font>是m（m>=0)棵互不相交的树的集合，根结点删除就变成了森林，给森林中的各子树加上一个双亲结点，森林就变成了树





### 二叉树的定义

为什么要研究二叉树？

答：二叉树结构最简单，规律性最强；可以证明，所有树都能转为唯一对应的二叉树，不失一般性；普通树若不转换为二叉树，则运算很难实现。二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法简单，而任何树都可以与二叉树相互转换，这就解决了树的存储结构及其运算中存在的复杂性。



**定义**

二叉树是n（n>=0）个结点的有限集，它或者是空集，或者由一个<font color="blue">根结点</font>及<font color="red">两个互不相交</font>的分别称作这个根的<font color="blue">左子树</font>和<font color="blue">右子树</font>的二叉树组成。



**特点**

1. 每个结点最多有两个孩子<font color="red">（二叉树中不存在度大于2的结点）</font>
2. 子树有左右之分，其次序不能颠倒
3. 二叉树可以是空集合，根可以有空的左子树或空的右子树



<font color="red">注：</font>二叉树不是树的特殊情况，它们是两个概念。二叉树的子树要区分左子树和右子树，即使只有一个子树也要区分；而当树的结点只有一个孩子时，就无须区分它是左还是右的次序。这是两者之间最大的差别。



### 二叉树的抽象数据类型定义

**二叉树的抽象数据类型定义**

```
ADT BinaryTree{
	数据对象D：D是具有相同特性的数据元素的集合
	数据关系R：若D=∅，则R=∅
			  若D≠∅，则R={H},H是如下二元关系
			  1. root唯一//关于根的说明
			  2. ......//子树不相交
			  3. ......//关于数据元素的说明
			  4. ......//关于左子树和右子树的说明
	基本操作P：//至少有20个
}ADT BinaryTree
```

**比较重要的几个操作：**

```
CreateBiTree(&T,definition)
	初始条件：definition给出二叉树T的定义	//definition是指构造方式（先序...)
	操作结果：按definition构造二叉树T
PreOrderTraverse(T)
	初始条件：二叉树T存在
	操作结果：先序遍历T，对每个结点访问一次
InOrderTraverse(T)
	初始条件：二叉树T存在
	操作结果：中序遍历T，对每个结点访问一次
PostOrderTraverse(T)
	初始条件：二叉树T存在
	操作结果：后序遍历T，对每个结点访问一次
```





### 二叉树的性质

<font color="red">性质1：</font>在二叉树的第i层上<font color="blue">最多</font>有2^i-1^个结点（i>=1）

<font color="red">性质2：</font>深度为k的二叉树<font color="blue">最多</font>有2^k^-1个结点（k>=1）	<font color="red">深度为k时至少有k个结点</font>

<font color="red">性质3：</font>对任意一颗二叉树T，如果其叶子数为n~0~，度为2的结点数为n~2~，则<font color="red">n~0~=n~2~+1</font>

从下往上：结点数为n，总边数为B，则有B = n-1（除了根节点每个结点都与双亲有一条连线）

从上往下：B = n~2~ * 2 + n~1~ * 1

B = n~2~ * 2 + n~1~ * 1 =  n - 1

n = n~2~ * 2 + n~1~ * 1 + 1

又因为n = n~0~ + n~1~ + n~2~	两式相结合得到 n~0~=n~2~+1



**两种特殊形式的二叉树**

**满二叉树**

一颗深度为k且有2^k^-1个结点的二叉树称为<font color="blue">满二叉树</font>

特点：1. 每层都满	2. 叶子结点全部在最底层

对满二叉树结点位置进行编号：从根结点开始，从上至下，从左至右。每一结点位置都有元素。

* 满二叉树在同样深度的二叉树中<font color="red">结点</font>个数最多
* 满二叉树在同样深度的二叉树中<font color="red">叶子结点</font>个数最多



**完全二叉树**

深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号为1~n的结点<font color="red">一一对应</font>时，称为完全二叉树

注：在满二叉树中，从最后一个结点开始<font color="red">连续</font>去掉<font color="red">任意</font>个结点，即是一棵完全二叉树

特点：1. 叶子只可能分布在层次最大的两层上

​			2. 对任一结点，如果其右子树的最大层数为i，则其左子树的最大层数为i或者i+1



<font color="red">性质4：</font>具有n个结点的完全二叉树的深度为⌊ log~2~n ⌋ + 1		(完全二叉树结点n与深度k的关系)

<font color="red">性质5：</font>如果对一颗有n个结点的完全二叉树的结点按层序编号（从第1层到第⌊ log~2~n ⌋ + 1层，每层从左到右），则对任一结点i（1<=i<=n），有

1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其<font color="red">双亲结点是⌊ i / 2 ⌋</font>
2. 如果2i>n，则结点i为叶子结点，无左孩子；否则，其<font color="red">左孩子结点是2i</font>
3. 如果2i + 1>n，则结点i无右孩子；否则，其<font color="red">右孩子结点是2i+1</font>

性质5表明了完全二叉树中<font color="red">双亲结点编号</font>与<font color="red">孩子结点编号</font>之间的关系

<font color="red">性质6：</font>





### 二叉树的存储结构

#### 二叉树的顺序存储

按<font color="red">满二叉树</font>的结点层次编号，依次存放二叉树中的数据元素

```c++
//二叉树顺序存储表示
#define MAXTSIZE 100
typedef TElemType SqBiTree[MAXSIZE];	//定义了一种数组类型，元素类型TElemType
SqBiTree bt;
```

若二叉树不是完全二叉树，也同样存储，没有元素的结点就空着，存0

二叉树的顺序存储缺点：

最坏情况：深度为k且只有k个结点的单支树需要长度为2^k^-1的一维数组

结点间关系蕴含在其存储位置中，浪费空间，适于存<font color="red">满二叉树和完全二叉树</font>



#### 二叉树的链式存储结构

二叉链表存储结构

```
typedef struct BiNode{
	TElemType data;
	struct BiNode *lchild,*rchild;	//左右孩子指针
}BiNode,*BiTree;
```



在n个结点的二叉链表中，必有<font color="red">2n</font>个链域。除根结点外，每个结点有且仅有一个双亲，所以会有<font color="red">n-1</font>个结点的链域存放指针，指向非空子女结点。所以，在n个结点的二叉链表中

<font color="red">空指针数目= 2n - (n-1) = n +1</font>



#### 三叉链表

三个指针域：lchild、rchild、parent

```c++
typedef struct TriTNode{
    TElemType data;
    struct TriTNode *lchid,*rchild,*parent;
}TriTNode,*TriTree;
```





### 遍历二叉树

<font color="red">遍历：</font>顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。[“访问”的含义很广，可以是对结点做各种处理，如：输出结点信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构]

<font color="red">遍历目的：</font>得到树中所有结点的一个线性排列

<font color="red">遍历用途：</font>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心



#### 遍历二叉树算法描述

**遍历方法**

若规定**先左后右**，则只有三种情况：

DLR - 先序遍历

LDR - 中序遍历

LRD - 后序遍历

|        先序遍历二叉树        |        中序遍历二叉树        |        后序遍历二叉树        |
| :--------------------------: | :--------------------------: | :--------------------------: |
| 若二叉树为空，则空操作；否则 | 若二叉树为空，则空操作；否则 | 若二叉树为空，则空操作；否则 |
|         1.访问根结点         |       1.中序遍历左子树       |       1.后序遍历左子树       |
|       2.先序遍历左子树       |         2.访问根结点         |       2.后序遍历右子树       |
|       3.先序遍历右子树       |       3.中序遍历右子树       |         3.访问根结点         |



#### 根据遍历序列确定二叉树

* 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的
* 由二叉树的<font color="red">先序序列和中序序列</font>，或由二叉树的<font color="red">后序序列和中序序列</font>可以确定唯一一颗二叉树



**已知先序和中序序列求二叉树**

分析：由先序序列确定根，由中序序列确定左右子树



**已知中序和后序序列求二叉树**

分析：由后序序列确定根，由中序序列确定左右子树





#### 遍历的算法实现

##### 先序遍历

存储结构：二叉链表

方法：递归

```c++
Status PreOrderTraverse(BiTree T){		//递归后传递进来的就是T->child的值了
	if(T==NULL) return OK;
	else{
		visit(T);	//访问根结点	例如，输出根结点：cout<<T->data;
		PreOrderTraverse(T->lchild);	//递归遍历左子树
		PreOrderTraverse(T->rchild);	//递归遍历右子树
	}
}
```

```c++
void Pre(BiTree T){			//例子
	if(T!=NULL){
		cout<<T->data;
		pre(T->lchild);
		pre(T->rchild);
	}
}
```





##### 中序遍历

```c++
Status InOrderTraverse(BiTree T){	//中序遍历
	if(T==NULL) return OK;
    else{
        InOrderTraverse(T->lchild);
        visit(T);
        InOrderTraverse(T->rchild);
    }
}
```



##### 后序遍历

```c++
Status PostOrderTraverse(BiTree T){	//后序遍历
	if(T==NULL) return OK;
	else{
		PostOrderTraverse(T->lchild);
		PostOrderTraverse(T.>rchild);
		visit(T);
	}
}
```



#### 遍历算法的分析

如果去掉输出语句，从递归的角度看，三种算法是完全相同得分，或者说着三种算法的访问路径是相同的，只是访问节点的时机不同。

第1次经过时访问 = 先序遍历

第2次经过时访问 = 中序遍历

第3次经过时访问 = 后序遍历



时间复杂度O（n）	//每个结点只访问一次

空间复杂度O（n）	//栈占用的最大辅助空间（都是左子树或者都是右子树）



#### 遍历二叉树的非递归算法

##### 中序遍历非递归算法

关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树

<font color="red">基本思想：</font>

1. 建立一个<font color="red">栈</font>
2. <font color="red">根</font>结点<font color="red">进栈</font>，遍历<font color="red">左子树</font>
3. <font color="red">根</font>结点<font color="red">出栈</font>，输出根结点，遍历<font color="red">右子树</font>



```c++
Status InOrderTraver(BiTree T){		//T是根结点
    BiTree p; InitStack(S); p = T;	//p是当前要出栈或者入栈的结点
    while(p||!StackEmpty(S)){
        if(p) {push(S,p); p = p->lchild;}
        else  {pop(S,q); cout<<q->data; p = q->rchild;}	//q是栈顶元素
    }
    return OK;
}
```



#### 二叉树的层次遍历

对于一颗二叉树，从根结点开始，按<font color="red">从上到下、从左到右</font>的顺序访问每一个结点。每个结点仅访问一次。

实现的关键：<font color="red">顺序循环队列</font>

队列类型定义如下

```c++
typedef struct{
	BTNode data[MAXSIZE];	//存放队中元素
	int front, rear;		//队头和队尾指针
}SqQueue;
```

层次遍历算法

```c++
void LevelOrder(BTNode &b){
	BTNode *p; SqQueue *qu;	p = b;
	InitQueue(qu);				//初始化队列
	enQueue(qu,b);				//根结点指针进入队列
	while(!QueueEmpty(qu)){		//队不为空，则循环
		deQueue(qu,p);			//出队结点p（应该是队首元素）
		cout<<p->data;			//访问结点p
		if(p->lchild != NULL) enQueue(qu,p->lchild);	//有左孩子时将其进队
		if(p->rchild !=NULL) enQueue(qu,p->rchild);		//有右孩子时将其进队
	}
}
```



#### 二叉树的建立

**按先序遍历建立二叉树的二叉链表**

例：ABCDEGF	如果只这么输入，树不是唯一的，所以<font color="red">空结点用其他符号表示</font>

```c++
Status CreateBiTree(BiTree &T){
	char ch;
    cin>>ch;
    if(ch == '#') T == NULL;
    else{
        if(!(T = new BiTNode)) exit(OVERFLOW);
        T->data = ch;				//生成根结点
        createBiTree(T->lchild);	//构造左子树
        createBiTree(T->rchild);	//构造右子树
    }
    return OK;
}
```



#### 复制二叉树

**先序遍历复制二叉树**

* 如果是空树，递归结束；
* 否则，申请新结点空间，复制根结点
  * 递归复制左子树
  * 递归复制右子树

```c++
int Copy(BiTree, BiTree &NewT){
	if(BtTree == NULL){
		NewT = NULL; return 0;	//如果是空树返回0
	}
	else{
		NewT = new BiTNode;		//内存中申请一块新结点空间
		NewT->data = T->data;	//将data域中的值复制到新结点当中
		Copy(T->lchild, NewT->lchild);	//递归复制左子树
		Copy(T->rchild, NewT->rchild);	//递归复制右子树
	}
}
```





#### 计算二叉树深度

* 如果是空树，深度为0
* 否则，递归计算左子树的深度为m，递归计算右子树的深度为n，二叉树的深度为m和n的较大者加1

```c++
int Depth(BiTree){
	if(T == NULL) return 0;
	else{
		m = Depth(T->lchild);
		n = Depth(T->rchild);
		return m>n?m+1:n+1;
	}
}
```





#### 计算二叉树结点总个数

* 如果是空树，则结点个数为0
* 否则，结点个数为左子树结点个数+右子树结点个数+1（根结点）

```c++
int NodeCount(BiTree T){
	if(T == NULL) return 0;
	else return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;
}
```





#### 计算二叉树叶子结点树

* 如果是空树，叶子结点个数为0
* 否则，为左子树的叶子结点树+右子树的叶子结点数

```c++
int LeafCount(BiTree T){
	if(T == NULL) return 0;		//如果是空树返回0
	if(T->lchild == NULL && T->rchild == NULL) return 1; //如果是叶子结点返回1
	else return LeafCount(T->lchild)+LeafCount(T->rchild);
}
```







### 线索二叉树

**为什么要研究线索二叉树**？

当用二叉链作为存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，<font color="red">无法直接找到该结点在某种遍历序列中的前驱和后继结点</font>



**如何寻找特定遍历序列中二叉树结点的前驱和后继？**

解决方法：

1. 通过遍历寻找						费时间
2. 添加前驱、后继指针域         费空间
3. <font color="red">利用二叉链表的空指针域</font>



**二叉链表中空指针域的数量**

n个结点的二叉树有2n个指针域，n个结点中有<font color="red">n-1</font>个孩子，即在2n个指针域中，有n-1个用来指示结点的左右孩子，其余 2n - (n-1) = <font color="red">n + 1 个指针域为空</font>



**利用二叉链表中的空指针域**

如果某个结点的左孩子为空，则将空的左孩子指针域改为<font color="red">指向其前驱</font>；如果某结点的右孩子为空，则将空的右孩子的指针域改为<font color="red">指向其后继</font>

这种<font color="red">改变指向的指针</font>称为<font color="red">“线索”</font>

加上了线索的二叉树称为<font color="red">线索二叉树</font>

对二叉树按某种遍历次序使其变为线索二叉树的过程叫做<font color="red">线索化</font>





**区分孩子指针和前驱后继指针**

为了区分lchild和rchild指针到底是指向孩子的指针，还是指向前驱和后继的指针，对二叉链表中<font color="red">每个结点增设两个标志域 ltag 和 rtag</font>

ltag = 0	lchild指向该结点的左孩子

ltag = 1	lchild指向该结点的前驱

rtag = 0	rchild指向该结点的右孩子

rtag = 1	rchild指向该结点的后继



#### 结点的结构

```c++
typedef struct BiThrNode{
	int data;
    int ltag,rtag;
    struct BiThrNode *lchild,*rchild;
}BiThrNode,*BiThrTree;
```



#### **增加一个头结点**

为了防止指针域悬空态，增加一个头结点，指针域为空的指向头结点

ltag=0，lchild指向根结点

rtag=1，rchild指向遍历序列中的最后一个结点

遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点







### 树和森林

#### 树的存储结构

##### 1.双亲表示法

实现：定义数据结构，每个结点含两个域

数据域：存放结点本身信息

双亲域：指示本结点的双亲结点在数组中的位置

r = 0  根结点位置	n = 10 结点数，方便定义数组

特点：找双亲容易，找孩子难



**结点的类型定义**

结点结构：

```c++
typedef struct PTNode{
	TElemType data;
	int parent;
}PTNode;
```

树结构：

```c++
#define MAX_TREE_SIZE 100
typedef struct{
	PTNode nodes[MAX_TREE_SIZE];
	int r,n;
}PTree;
```





##### 2.孩子链表

把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。

则n个结点有n个孩子链表（叶子的孩子链表为空表）。

而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。

特点：找孩子容易，找双亲难



**类型定义**

孩子结点结构

```c++
typedef struct CTNode{
	int child;
	struct CTNode *next;
}*ChildPtr;
```

双亲结点结构

```c++
typedef struct {
	TElemType data;
	ChildPtr firstchild;	//孩子链表头指针
}CTBox;
```

树结构

```c++
typedef struct {
	CTBox nodes[MAX_TREE_SIZE];
	int n,r;	//结点数和根结点的位置
}CTree;
```



为了方便操作，可以在数据域中再增加一个双亲的下标位置。<font color="red">带双亲的孩子链表。</font>





##### 3.孩子兄弟表示法

实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其<font color="red">第一个孩子结点</font>和<font color="red">下一个兄弟结点</font>

```c++
typdedef struct CSNode{
	ElemType data;
	struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

特点：查找孩子容易，查找双亲难
